#include "enumbra_test.hpp"

using namespace enumbra;
using namespace enums;

struct V
{
    ENUMBRA_PACK(test_nodefault, W);
    ENUMBRA_PACK(test_nodefault, X);
    ENUMBRA_PACK(test_nodefault, Y);
    ENUMBRA_PACK(test_nodefault, Z);
};
static_assert(sizeof(V) == 2);

template<typename T>
void test_templated(const T& value)
{
    static_assert(is_enumbra_type_v<T>, "value must be an enumbra class or an enum class generated by enumbra.");
    using enumbra_type = enumbra_base_t<T>;

    static_assert(enumbra_type::is_enumbra_flags_enum());

    constexpr auto min = enumbra_type::min();
    constexpr auto max = enumbra_type::max();

    enumbra_type v = value;

    if constexpr (is_enumbra_scoped_enum_v<T>) {
        // T is an enum class
        v = value;
    }
    else
    {
        // T is an enumbra type
    }
}

template<typename T>
void test_value_vs_flags()
{
    if constexpr (is_enumbra_flags_enum_v<T>) {
        static_assert(enumbra_base_t<T>::is_enumbra_flags_enum());
        enumbra_base_t<T> x;
        x.reset_zero(); // Only flags should have this function
    }
    else if constexpr (is_enumbra_value_enum_v<T>) {
        static_assert(enumbra_base_t<T>::is_enumbra_value_enum());
    }
    else {
        static_assert(false, "T is not an enumbra type.");
    }
}

// Parameter is const& so we can pass in all types here, even bitfields
template<typename T>
void test_is_enumbra_type(const T& value)
{
    if constexpr (is_enumbra_struct_v<T>) {
        // T is an enumbra class type.
        constexpr auto min = T::min();

        T x = value;
        x.reset_zero();
    }
    else if constexpr (is_enumbra_scoped_enum_v<T>)
    {
        // T is an 'enum class' contained within an enumbra struct type.
        // T is convertible from its enum class type to its parent struct type with enumbra_base_t
        using base_type = enumbra_base_t<T>;
        constexpr auto min = base_type::min();

        base_type x = value;
        x.reset_zero();
    }
    else if constexpr (std::is_enum_v<T>)
    {
        // TODO: C++23 check is_scoped_enum<T>
        // T is just a regular c++ enum type.
        T x = T();
    }
    else
    {
        static_assert(false, "T is not an enum class or enumbra type.");
    }
}

enum class NonEnumbraEnum
{
    A = 0,
    B = 1
};

int main()
{
    constexpr test_nodefault a = test_nodefault::B | test_nodefault::C;
    static_assert(a.test(test_nodefault::B | test_nodefault::C));

    test_nodefault d;

    d = test_nodefault::B;
    d = test_nodefault::B | test_nodefault::C;
    d = test_nodefault::B & test_nodefault::C;
    d = test_nodefault::B ^ test_nodefault::C;
    d |= test_nodefault::B | test_nodefault::C;
    d &= test_nodefault::B & test_nodefault::C;
    d ^= test_nodefault::B ^ test_nodefault::C;
    d |= d;
    d &= d;
    d ^= d;
    d = ~d;
    d = d | d;
    d = d & d;
    d = d ^ d;
    d = d | test_nodefault::B;
    d = d & test_nodefault::B;
    d = d ^ test_nodefault::B;
    d = test_nodefault::B | d;
    d = test_nodefault::B & d;
    d = test_nodefault::B ^ d;

    bool b;
    b = (d == d);
    b = (d != d);
    b = (d == test_nodefault::B);
    b = (d != test_nodefault::B);
    b = (test_nodefault::B == d);
    b = (test_nodefault::B != d);

    // Test packed bitfields
    V v;
    v.X = test_nodefault::B;
    v.Y = test_nodefault::B | test_nodefault::C;
    v.Z = d;
    d = v.X; // uses implicit constructor

    test_nodefault::Value vv{};
    vv = ~vv;

    test_is_enumbra_type(d);
    test_is_enumbra_type(d.value());
    test_is_enumbra_type(v.X);
    test_is_enumbra_type(vv);
    test_is_enumbra_type(NonEnumbraEnum::A);
}