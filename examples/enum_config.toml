# This configuration file uses TOML syntax: https://toml.io/en/

# See the documentation for enum configuration here: https://github.com/scaless/enumbra

[enum_meta]

# Unique name for this block of enums.
# This is used in:
#   c_style header guards (automatically uppercased): ENUMBRA_BLOCKNAME_H
block_name = "blockname"

# Value to use when generating default enum_value functions. 
# Valid Options:
#   "min": The smallest entry in the values[] table. If an enum contains duplicate minimum values, the name of the first occurrence will be used.
#   "max": The largest entry in the values[] table. If an enum contains duplicate maximum values, the name of the first occurrence will be used.
#   "first": The first entry in the values[] table following the user-defined order.
#   "last": The last entry in the values[] table following the user-defined order.
value_enum_default_value_style = "min"

# Value to use when generating default enum_flags functions. 
# Valid Options:
#   "zero": Default value is 0.
#   "used_bits_set": Default value equal to all valid values OR'd together. 
#   "min": The smallest entry in the values[] table. If an enum contains duplicate minimum values, the name of the first occurrence will be used.
#   "max": The largest entry in the values[] table. If an enum contains duplicate maximum values, the name of the first occurrence will be used.
#   "first": The first entry in the values[] table following the user-defined order.
#   "last": The last entry in the values[] table following the user-defined order.
flags_enum_default_value_style = "zero"

# If true, a value_enum is required to contain sequential values.
# Sequential values may allow generated functions to create slightly faster code since gaps do not need to be handled.
# values = [
#     { name = "A", value = 1 },
#     { name = "B", value = 2 }, 
#     { name = "C", value = 4 }, 
#                           ^ ERROR! 3 is skipped, sequence is not linear
# ]
value_enum_require_sequential = true

# If true, a flags_enum must contain values which when OR'd together result in a sequence of set bits starting from the lowest bit.
# This is useful for making sure your enums are as packed as possible.
# If you do not have control over the bit patterns that you are using, you'll probably wont want to use this.
# values = [
#     { name = "A", value = 0b1000 },
#     { name = "B", value = 0b0110 }, 
#                                ^ ERROR! bit is never used
# ]
flags_enum_require_packed_bits = true

# Require a value_enum to contain unique name:value pairs
value_enum_require_unique_values = true 

# Allow a flags_enum to contain values where bit patterns overlap.
# values = [
#     { name = "A", value = 0b1100 },
#     { name = "B", value = 0b0110 },
#                              ^ ERROR! Overlapping bits
# ]
flags_enum_allow_overlap = false

# Allow a flags_enum to contain values where multiple bits are set.
# values = [
#     { name = "A", value = 1 },
#     { name = "B", value = 2 }, 
#     { name = "C", value = 3 }, ERROR!
#     { name = "D", value = 4 },
# ]
flags_enum_allow_multi_bit_values = false

################################################
# Value Enums
################################################
[[enum_meta.value_enum]]
name = "test_value"
default_value = "B"
size_type = "signed32"
values = [
	{ name = "A", value = 0 },
	{ name = "B", value = 1 },
	{ name = "C", value = 2 },
]

[[enum_meta.value_enum]]
name = "HexDiagonal"
size_type = "unsigned8"
values = [
	{ name = "NORTH"},
	{ name = "NORTH_EAST"},
	{ name = "SOUTH_EAST"},
	{ name = "SOUTH"},
	{ name = "SOUTH_WEST"},
	{ name = "NORTH_WEST"},
]

[[enum_meta.value_enum]]
name = "NegativeTest1"
size_type = "signed8"
values = [
	{ name = "A", value = -2 },
	{ name = "B", value = -1 },
	{ name = "C", value = 0 },
	{ name = "D", value = 1 },
]

[[enum_meta.value_enum]]
name = "NegativeTest2"
size_type = "signed8"
values = [
	{ name = "A", value = -3 },
	{ name = "B", value = -2 },
	{ name = "C", value = -1 },
	{ name = "D", value = 0 },
]

[[enum_meta.value_enum]]
name = "NegativeTest3"
size_type = "signed8"
values = [
	{ name = "A", value = -3 },
	{ name = "B", value = 4 },
]

[[enum_meta.value_enum]]
name = "NegativeTest4"
size_type = "signed8"
values = [
	{ name = "A", value = -4 },
	{ name = "B", value = 3 },
]

[[enum_meta.value_enum]]
name = "EmptyTest1Unsigned"
size_type = "unsigned8"
values = [
	{ name = "A", value = 0 },
]

[[enum_meta.value_enum]]
name = "EmptyTest1Signed"
size_type = "signed8"
values = [
	{ name = "A", value = 0 },
]

[[enum_meta.value_enum]]
name = "SingleTest1Unsigned"
size_type = "unsigned8"
values = [
	{ name = "A", value = 4 },
]

[[enum_meta.value_enum]]
name = "SingleTest1Signed"
size_type = "signed8"
values = [
	{ name = "A", value = 4 },
]

################################################
# Flags Enums
################################################
[[enum_meta.flags_enum]]
name = "test_flags"
values = [
	{ name = "B", value = 0x1 },
	{ name = "C", value = 0x2 },
]

[[enum_meta.flags_enum]]
name = "test_nodefault"
default_value = "C"
size_type = "unsigned16"
values = [
	{ name = "B", value = 0x1 },
	{ name = "C", value = 0x2 },
]

[[enum_meta.flags_enum]]
name = "TestSparseFlags"
default_value = "C"
size_type = "unsigned16"
values = [
	{ name = "B", value = 0x1 },
	{ name = "C", value = 0x4 },
	{ name = "D", value = 0x10 },
]


[[enum_meta.flags_enum]]
name = "TestSingleFlag"
default_value = "C"
size_type = "unsigned16"
values = [
	{ name = "C", value = 0x4 },
]



