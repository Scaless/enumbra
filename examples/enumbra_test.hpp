// THIS FILE WAS GENERATED BY A TOOL (haha)
// Direct your feedback and monetary donations to: https://github.com/Scaless/enumbra
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated.
// Generated by enumbra v0.1.0

// You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should put it in your enumbra_config.json file!

#pragma once

#include <array>
#include <cstdint>

#if !defined(ENUMBRA_REQUIRED_MACROS_VERSION) 
#define ENUMBRA_REQUIRED_MACROS_VERSION 7

// Find out what language version we're using
// 2024-07-04:MSVC Doesn't officially support C++23 yet
#if (__cplusplus >= 202302L)
#define ENUMBRA_CPP_VERSION 23
#elif ((defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)) || (__cplusplus >= 202002L)
#define ENUMBRA_CPP_VERSION 20
#elif ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)) || (__cplusplus >= 201703L)
#define ENUMBRA_CPP_VERSION 17
#else
#error Headers generated by enumbra require a compiler that supports C++17 or higher.
#endif

#if defined(__clang__)
#define ENUMBRA_COMPILER_CLANG
#elif defined(__GNUG__)
#define ENUMBRA_COMPILER_GCC
#elif defined(_MSC_VER)
#define ENUMBRA_COMPILER_MSVC
#else
#define ENUMBRA_COMPILER_UNKNOWN
#endif

#if defined(ENUMBRA_USER_UNREACHABLE)
#define ENUMBRA_UNREACHABLE ENUMBRA_USER_UNREACHABLE
#else
#define ENUMBRA_UNREACHABLE
#endif

#else // check existing version supported 
#if (ENUMBRA_REQUIRED_MACROS_VERSION + 0) == 0 
#error ENUMBRA_REQUIRED_MACROS_VERSION has been defined without a proper version number. Check your build system. 
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) < 7 
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version. 
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) > 7 
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version. 
#endif // end check existing version supported
#endif // ENUMBRA_REQUIRED_MACROS_VERSION

#if !defined(ENUMBRA_OPTIONAL_MACROS_VERSION)
#define ENUMBRA_OPTIONAL_MACROS_VERSION 6

// Bitfield convenience functions
#define ENUMBRA_ZERO(Field) { decltype(Field) _field_ = Field; zero(_field_); Field = _field_; }
#define ENUMBRA_SET(Field, Value) { decltype(Field) _field_ = Field; set(_field_, Value); Field = _field_; }
#define ENUMBRA_UNSET(Field, Value) { decltype(Field) _field_ = Field; unset(_field_, Value); Field = _field_; }
#define ENUMBRA_TOGGLE(Field, Value) { decltype(Field) _field_ = Field; toggle(_field_, Value); Field = _field_; }

// Bit field storage helper
#define ENUMBRA_PACK_UNINITIALIZED(Enum, Name) Enum Name : ::enumbra::bits_required_storage<Enum>();
#define ENUMBRA_INIT(Name, InitValue) Name(::enumbra::default_value<decltype(Name)>())
#define ENUMBRA_INIT_DEFAULT(Name) Name(::enumbra::default_value<decltype(Name)>())

#if ENUMBRA_CPP_VERSION >= 20
// Bit field storage helper with type-checked member initialization
#define ENUMBRA_PACK_INIT(Enum, Name, InitValue) Enum Name : ::enumbra::bits_required_storage<Enum>() { InitValue };
// Bit field storage helper with default value initialization
#define ENUMBRA_PACK_INIT_DEFAULT(Enum, Name) Enum Name : ::enumbra::bits_required_storage<Enum>() { ::enumbra::default_value<Enum>() };
#endif

#else // check existing version supported
#if (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) == 0
#error ENUMBRA_OPTIONAL_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) < 6
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) > 6
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_OPTIONAL_MACROS_VERSION

#if !defined(ENUMBRA_BASE_TEMPLATES_VERSION)
#define ENUMBRA_BASE_TEMPLATES_VERSION 8
namespace enumbra {
    namespace detail {
        // Type info
        template<bool is_enumbra, bool is_value_enum, bool is_flags_enum>
        struct type_info { 
            static constexpr bool enumbra_type = is_enumbra;
            static constexpr bool enumbra_value_enum = is_value_enum;
            static constexpr bool enumbra_flags_enum = is_flags_enum;
        };

        // Value enum info
        template<typename underlying_type, underlying_type min_v, underlying_type max_v,
            underlying_type default_v, typename count_type, count_type count_v,
            bool is_contiguous_v, int bits_required_storage_v, int bits_required_transmission_v>
        struct value_enum_info {
            using underlying_t = underlying_type;
            static constexpr underlying_type min = min_v;
            static constexpr underlying_type max = max_v;
            static constexpr underlying_type def = default_v;
            static constexpr count_type count = count_v;
            static constexpr bool is_contiguous = is_contiguous_v;
            static constexpr int bits_required_storage = bits_required_storage_v;
            static constexpr int bits_required_transmission = bits_required_transmission_v;
        };

        // Flags enum info
        template<typename underlying_type, underlying_type min_v, underlying_type max_v, 
            underlying_type default_v, typename count_type, count_type count_v,
            bool is_contiguous_v, int bits_required_storage_v, int bits_required_transmission_v>
        struct flags_enum_info {
            using underlying_t = underlying_type;
            static constexpr underlying_type min = min_v;
            static constexpr underlying_type max = max_v;
            static constexpr underlying_type def = default_v;
            static constexpr count_type count = count_v;
            static constexpr bool is_contiguous = is_contiguous_v;
            static constexpr int bits_required_storage = bits_required_storage_v;
            static constexpr int bits_required_transmission = bits_required_transmission_v;
        };
        
        // Default template for non-enumbra types
        template<class T>
        struct base_helper : type_info<false, false, false> { };
        template<class T>
        struct value_enum_helper;
        template<class T>
        struct flags_enum_helper;

        // Constexpr string compare
        template<class T> constexpr bool streq_s(T* a, std::size_t a_len, T* b, std::size_t b_len) {
            if(a == nullptr) { return false; }
            if(b == nullptr) { return false; }
            if(a_len != b_len) { return false; }
#if defined(ENUMBRA_COMPILER_CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif
            for(std::size_t i = 0; i < a_len; ++i) { if(a[i] != b[i]) { return false; } }
#if defined(ENUMBRA_COMPILER_CLANG)
#pragma clang diagnostic pop
#endif
            return true;
        }
        template<class T> constexpr bool streq_known_size(T* a, T* b, std::size_t len) {
            if(a == nullptr) { return false; }
            if(b == nullptr) { return false; }
#if defined(ENUMBRA_COMPILER_CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif
            for(std::size_t i = 0; i < len; ++i) { if(a[i] != b[i]) { return false; } }
#if defined(ENUMBRA_COMPILER_CLANG)
#pragma clang diagnostic pop
#endif
            return true;
        }
    } // end namespace enumbra::detail
    template<class T> constexpr bool is_enumbra_enum() { return detail::base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_enum(T) { return detail::base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_value_enum() { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_value_enum(T) { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum() { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_flags_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum(T) { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_flags_enum; }
    
    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr T min() { return static_cast<T>(detail::value_enum_helper<T>::min); }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr T min() { return static_cast<T>(detail::flags_enum_helper<T>::min); }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T min() = delete;

    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr T max() { return static_cast<T>(detail::value_enum_helper<T>::max); }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr T max() { return static_cast<T>(detail::flags_enum_helper<T>::max); }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T max() = delete;

    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr T default_value() { return static_cast<T>(detail::value_enum_helper<T>::def); }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr T default_value() { return static_cast<T>(detail::flags_enum_helper<T>::def); }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T default_value() = delete;

    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr int count() { return detail::value_enum_helper<T>::count; }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr int count() { return detail::flags_enum_helper<T>::count; }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr int count() = delete;

    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr bool is_contiguous() { return detail::value_enum_helper<T>::is_contiguous; }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr bool is_contiguous() { return detail::flags_enum_helper<T>::is_contiguous; }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr bool is_contiguous() = delete;

    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_storage() { return detail::value_enum_helper<T>::bits_required_storage; }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_storage() { return detail::flags_enum_helper<T>::bits_required_storage; }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_storage() = delete;

    template<class T, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_transmission() { return detail::value_enum_helper<T>::bits_required_transmission; }
    template<class T, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_transmission() { return detail::flags_enum_helper<T>::bits_required_transmission; }
    template<class T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_transmission() = delete;

    template<class T, class underlying_type = typename detail::base_helper<T>::base_type, typename std::enable_if<is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T from_underlying_unsafe(underlying_type e) { return static_cast<T>(e); }
    template<class T, class underlying_type = typename detail::base_helper<T>::base_type, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T from_underlying_unsafe(underlying_type e) = delete;

    template<class T, class underlying_type = typename detail::value_enum_helper<T>::underlying_t, typename std::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr underlying_type to_underlying(T e) { return static_cast<underlying_type>(e); }
    template<class T, class underlying_type = typename detail::flags_enum_helper<T>::underlying_t, typename std::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr underlying_type to_underlying(T e) { return static_cast<underlying_type>(e); }
    template<class T, class underlying_type = T, typename std::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr underlying_type to_underlying(T e) = delete;

} // end namespace enumbra
#else // check existing version supported
#if (ENUMBRA_BASE_TEMPLATES_VERSION + 0) == 0
#error ENUMBRA_BASE_TEMPLATES_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) < 8
#error An included header was generated using a newer version of enumbra. Regenerate your headers using same version of enumbra.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) > 8
#error An included header was generated using an older version of enumbra. Regenerate your headers using same version of enumbra.
#endif // check existing version supported
#endif // ENUMBRA_BASE_TEMPLATES_VERSION

namespace enums {

    // Begin Default Templates
    template<class T>
    constexpr std::pair<bool, T> from_string(const char* str, std::size_t len) = delete;

    template<class T>
    constexpr auto& values() = delete;

    template<class T>
    constexpr auto& flags() = delete;

    template<class T, class underlying_type = typename ::enumbra::detail::base_helper<T>::base_type>
    constexpr bool is_valid(underlying_type value) = delete;
    // End Default Templates

    // test_string_parse Definition
    enum class test_string_parse : int64_t {
        B = 1,
        C = -1,
        D = 511,
        E = 9223372036854775807,
        F = 341,
    };

    namespace detail { namespace test_string_parse {
        constexpr std::array<::enums::test_string_parse, 5> values_arr =
        {{
            ::enums::test_string_parse::B,
            ::enums::test_string_parse::C,
            ::enums::test_string_parse::D,
            ::enums::test_string_parse::E,
            ::enums::test_string_parse::F,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            1,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 5),
        }};
        constexpr std::array<const char*, 5> enum_strings = {{
            "B",
            "C",
            "D",
            "E",
            "F",
        }};
        constexpr std::array<::enums::test_string_parse, 5> enum_string_values = {{
            ::enums::test_string_parse::B,
            ::enums::test_string_parse::C,
            ::enums::test_string_parse::D,
            ::enums::test_string_parse::E,
            ::enums::test_string_parse::F,
        }};
    }}

    template<>
    constexpr auto& values<test_string_parse>()
    {
        return detail::test_string_parse::values_arr;
    }

    template<>
    constexpr bool is_valid<test_string_parse>(int64_t v) {
        const test_string_parse test = static_cast<test_string_parse>(v);
        for(std::size_t i = 0; i < values<test_string_parse>().size(); i++) {
            const auto& val = values<test_string_parse>()[i];
            if(val == static_cast<test_string_parse>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const test_string_parse v) {
        switch (v) {
            case test_string_parse::B: return "B";
            case test_string_parse::C: return "C";
            case test_string_parse::D: return "D";
            case test_string_parse::E: return "E";
            case test_string_parse::F: return "F";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, test_string_parse> from_string<test_string_parse>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, test_string_parse());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::test_string_parse::string_sizes.size(); ++i) {
            const auto& current = detail::test_string_parse::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::test_string_parse::string_offset_and_counts[i].first;
                count = detail::test_string_parse::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::test_string_parse::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::test_string_parse::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // Unsigned64Test Definition
    enum class Unsigned64Test : uint64_t {
        MAX = 0xFFFFFFFFFFFFFFFF,
        MIN = 0,
        V_UINT16_MAX = 0xFFFF,
        V_UINT32_MAX = 0xFFFFFFFF,
    };

    namespace detail { namespace Unsigned64Test {
        constexpr std::array<::enums::Unsigned64Test, 4> values_arr =
        {{
            ::enums::Unsigned64Test::MAX,
            ::enums::Unsigned64Test::MIN,
            ::enums::Unsigned64Test::V_UINT16_MAX,
            ::enums::Unsigned64Test::V_UINT32_MAX,
        }};
        constexpr std::array<std::size_t, 2> string_sizes = {{
            3,
            12,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 2> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
            std::make_pair<std::size_t, std::size_t>(2, 2),
        }};
        constexpr std::array<const char*, 4> enum_strings = {{
            "MAX",
            "MIN",
            "V_UINT16_MAX",
            "V_UINT32_MAX",
        }};
        constexpr std::array<::enums::Unsigned64Test, 4> enum_string_values = {{
            ::enums::Unsigned64Test::MAX,
            ::enums::Unsigned64Test::MIN,
            ::enums::Unsigned64Test::V_UINT16_MAX,
            ::enums::Unsigned64Test::V_UINT32_MAX,
        }};
    }}

    template<>
    constexpr auto& values<Unsigned64Test>()
    {
        return detail::Unsigned64Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Unsigned64Test>(uint64_t v) {
        const Unsigned64Test test = static_cast<Unsigned64Test>(v);
        for(std::size_t i = 0; i < values<Unsigned64Test>().size(); i++) {
            const auto& val = values<Unsigned64Test>()[i];
            if(val == static_cast<Unsigned64Test>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const Unsigned64Test v) {
        switch (v) {
            case Unsigned64Test::MAX: return "MAX";
            case Unsigned64Test::MIN: return "MIN";
            case Unsigned64Test::V_UINT16_MAX: return "V_UINT16_MAX";
            case Unsigned64Test::V_UINT32_MAX: return "V_UINT32_MAX";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, Unsigned64Test> from_string<Unsigned64Test>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, Unsigned64Test());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::Unsigned64Test::string_sizes.size(); ++i) {
            const auto& current = detail::Unsigned64Test::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::Unsigned64Test::string_offset_and_counts[i].first;
                count = detail::Unsigned64Test::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::Unsigned64Test::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::Unsigned64Test::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // Signed64Test Definition
    enum class Signed64Test : int64_t {
        MIN = (-9223372036854775807 - 1),
        MAX = 9223372036854775807,
        NEG_ONE = -1,
    };

    namespace detail { namespace Signed64Test {
        constexpr std::array<::enums::Signed64Test, 3> values_arr =
        {{
            ::enums::Signed64Test::MIN,
            ::enums::Signed64Test::MAX,
            ::enums::Signed64Test::NEG_ONE,
        }};
        constexpr std::array<std::size_t, 2> string_sizes = {{
            3,
            7,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 2> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
            std::make_pair<std::size_t, std::size_t>(2, 1),
        }};
        constexpr std::array<const char*, 3> enum_strings = {{
            "MIN",
            "MAX",
            "NEG_ONE",
        }};
        constexpr std::array<::enums::Signed64Test, 3> enum_string_values = {{
            ::enums::Signed64Test::MIN,
            ::enums::Signed64Test::MAX,
            ::enums::Signed64Test::NEG_ONE,
        }};
    }}

    template<>
    constexpr auto& values<Signed64Test>()
    {
        return detail::Signed64Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed64Test>(int64_t v) {
        const Signed64Test test = static_cast<Signed64Test>(v);
        for(std::size_t i = 0; i < values<Signed64Test>().size(); i++) {
            const auto& val = values<Signed64Test>()[i];
            if(val == static_cast<Signed64Test>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const Signed64Test v) {
        switch (v) {
            case Signed64Test::MIN: return "MIN";
            case Signed64Test::MAX: return "MAX";
            case Signed64Test::NEG_ONE: return "NEG_ONE";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, Signed64Test> from_string<Signed64Test>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, Signed64Test());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::Signed64Test::string_sizes.size(); ++i) {
            const auto& current = detail::Signed64Test::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::Signed64Test::string_offset_and_counts[i].first;
                count = detail::Signed64Test::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::Signed64Test::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::Signed64Test::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // Signed32Test Definition
    enum class Signed32Test : int32_t {
        MIN = (-2147483647 - 1),
        MAX = 2147483647,
        NEG_ONE = -1,
    };

    namespace detail { namespace Signed32Test {
        constexpr std::array<::enums::Signed32Test, 3> values_arr =
        {{
            ::enums::Signed32Test::MIN,
            ::enums::Signed32Test::MAX,
            ::enums::Signed32Test::NEG_ONE,
        }};
        constexpr std::array<std::size_t, 2> string_sizes = {{
            3,
            7,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 2> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
            std::make_pair<std::size_t, std::size_t>(2, 1),
        }};
        constexpr std::array<const char*, 3> enum_strings = {{
            "MIN",
            "MAX",
            "NEG_ONE",
        }};
        constexpr std::array<::enums::Signed32Test, 3> enum_string_values = {{
            ::enums::Signed32Test::MIN,
            ::enums::Signed32Test::MAX,
            ::enums::Signed32Test::NEG_ONE,
        }};
    }}

    template<>
    constexpr auto& values<Signed32Test>()
    {
        return detail::Signed32Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed32Test>(int32_t v) {
        const Signed32Test test = static_cast<Signed32Test>(v);
        for(std::size_t i = 0; i < values<Signed32Test>().size(); i++) {
            const auto& val = values<Signed32Test>()[i];
            if(val == static_cast<Signed32Test>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const Signed32Test v) {
        switch (v) {
            case Signed32Test::MIN: return "MIN";
            case Signed32Test::MAX: return "MAX";
            case Signed32Test::NEG_ONE: return "NEG_ONE";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, Signed32Test> from_string<Signed32Test>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, Signed32Test());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::Signed32Test::string_sizes.size(); ++i) {
            const auto& current = detail::Signed32Test::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::Signed32Test::string_offset_and_counts[i].first;
                count = detail::Signed32Test::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::Signed32Test::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::Signed32Test::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // Signed16Test Definition
    enum class Signed16Test : int16_t {
        MIN = (-32767 - 1),
        MAX = 32767,
        NEG_ONE = -1,
    };

    namespace detail { namespace Signed16Test {
        constexpr std::array<::enums::Signed16Test, 3> values_arr =
        {{
            ::enums::Signed16Test::MIN,
            ::enums::Signed16Test::MAX,
            ::enums::Signed16Test::NEG_ONE,
        }};
        constexpr std::array<std::size_t, 2> string_sizes = {{
            3,
            7,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 2> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
            std::make_pair<std::size_t, std::size_t>(2, 1),
        }};
        constexpr std::array<const char*, 3> enum_strings = {{
            "MIN",
            "MAX",
            "NEG_ONE",
        }};
        constexpr std::array<::enums::Signed16Test, 3> enum_string_values = {{
            ::enums::Signed16Test::MIN,
            ::enums::Signed16Test::MAX,
            ::enums::Signed16Test::NEG_ONE,
        }};
    }}

    template<>
    constexpr auto& values<Signed16Test>()
    {
        return detail::Signed16Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed16Test>(int16_t v) {
        const Signed16Test test = static_cast<Signed16Test>(v);
        for(std::size_t i = 0; i < values<Signed16Test>().size(); i++) {
            const auto& val = values<Signed16Test>()[i];
            if(val == static_cast<Signed16Test>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const Signed16Test v) {
        switch (v) {
            case Signed16Test::MIN: return "MIN";
            case Signed16Test::MAX: return "MAX";
            case Signed16Test::NEG_ONE: return "NEG_ONE";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, Signed16Test> from_string<Signed16Test>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, Signed16Test());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::Signed16Test::string_sizes.size(); ++i) {
            const auto& current = detail::Signed16Test::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::Signed16Test::string_offset_and_counts[i].first;
                count = detail::Signed16Test::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::Signed16Test::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::Signed16Test::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // Signed8Test Definition
    enum class Signed8Test : int8_t {
        V_INT_MIN = (-127 - 1),
        V_INT_MAX = 127,
        V_NEG_ONE = -1,
    };

    namespace detail { namespace Signed8Test {
        constexpr std::array<::enums::Signed8Test, 3> values_arr =
        {{
            ::enums::Signed8Test::V_INT_MIN,
            ::enums::Signed8Test::V_INT_MAX,
            ::enums::Signed8Test::V_NEG_ONE,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            9,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 3),
        }};
        constexpr std::array<const char*, 3> enum_strings = {{
            "V_INT_MIN",
            "V_INT_MAX",
            "V_NEG_ONE",
        }};
        constexpr std::array<::enums::Signed8Test, 3> enum_string_values = {{
            ::enums::Signed8Test::V_INT_MIN,
            ::enums::Signed8Test::V_INT_MAX,
            ::enums::Signed8Test::V_NEG_ONE,
        }};
    }}

    template<>
    constexpr auto& values<Signed8Test>()
    {
        return detail::Signed8Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed8Test>(int8_t v) {
        const Signed8Test test = static_cast<Signed8Test>(v);
        for(std::size_t i = 0; i < values<Signed8Test>().size(); i++) {
            const auto& val = values<Signed8Test>()[i];
            if(val == static_cast<Signed8Test>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const Signed8Test v) {
        switch (v) {
            case Signed8Test::V_INT_MIN: return "V_INT_MIN";
            case Signed8Test::V_INT_MAX: return "V_INT_MAX";
            case Signed8Test::V_NEG_ONE: return "V_NEG_ONE";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, Signed8Test> from_string<Signed8Test>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, Signed8Test());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::Signed8Test::string_sizes.size(); ++i) {
            const auto& current = detail::Signed8Test::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::Signed8Test::string_offset_and_counts[i].first;
                count = detail::Signed8Test::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::Signed8Test::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::Signed8Test::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // test_value Definition
    enum class test_value : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    namespace detail { namespace test_value {
        constexpr std::array<::enums::test_value, 3> values_arr =
        {{
            ::enums::test_value::A,
            ::enums::test_value::B,
            ::enums::test_value::C,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            1,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 3),
        }};
        constexpr std::array<const char*, 3> enum_strings = {{
            "A",
            "B",
            "C",
        }};
        constexpr std::array<::enums::test_value, 3> enum_string_values = {{
            ::enums::test_value::A,
            ::enums::test_value::B,
            ::enums::test_value::C,
        }};
    }}

    template<>
    constexpr auto& values<test_value>()
    {
        return detail::test_value::values_arr;
    }

    template<>
    constexpr bool is_valid<test_value>(int32_t v) { return (0 <= v) && (v <= 2); }

    constexpr const char* to_string(const test_value v) {
        switch (v) {
            case test_value::A: return "A";
            case test_value::B: return "B";
            case test_value::C: return "C";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, test_value> from_string<test_value>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, test_value());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::test_value::string_sizes.size(); ++i) {
            const auto& current = detail::test_value::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::test_value::string_offset_and_counts[i].first;
                count = detail::test_value::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::test_value::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::test_value::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // HexDiagonal Definition
    enum class HexDiagonal : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    namespace detail { namespace HexDiagonal {
        constexpr std::array<::enums::HexDiagonal, 6> values_arr =
        {{
            ::enums::HexDiagonal::NORTH,
            ::enums::HexDiagonal::NORTH_EAST,
            ::enums::HexDiagonal::SOUTH_EAST,
            ::enums::HexDiagonal::SOUTH,
            ::enums::HexDiagonal::SOUTH_WEST,
            ::enums::HexDiagonal::NORTH_WEST,
        }};
        constexpr std::array<std::size_t, 2> string_sizes = {{
            5,
            10,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 2> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
            std::make_pair<std::size_t, std::size_t>(2, 4),
        }};
        constexpr std::array<const char*, 6> enum_strings = {{
            "NORTH",
            "SOUTH",
            "NORTH_EAST",
            "SOUTH_EAST",
            "SOUTH_WEST",
            "NORTH_WEST",
        }};
        constexpr std::array<::enums::HexDiagonal, 6> enum_string_values = {{
            ::enums::HexDiagonal::NORTH,
            ::enums::HexDiagonal::SOUTH,
            ::enums::HexDiagonal::NORTH_EAST,
            ::enums::HexDiagonal::SOUTH_EAST,
            ::enums::HexDiagonal::SOUTH_WEST,
            ::enums::HexDiagonal::NORTH_WEST,
        }};
    }}

    template<>
    constexpr auto& values<HexDiagonal>()
    {
        return detail::HexDiagonal::values_arr;
    }

    template<>
    constexpr bool is_valid<HexDiagonal>(uint8_t v) { return v <= 5; }

    constexpr const char* to_string(const HexDiagonal v) {
        switch (v) {
            case HexDiagonal::NORTH: return "NORTH";
            case HexDiagonal::NORTH_EAST: return "NORTH_EAST";
            case HexDiagonal::SOUTH_EAST: return "SOUTH_EAST";
            case HexDiagonal::SOUTH: return "SOUTH";
            case HexDiagonal::SOUTH_WEST: return "SOUTH_WEST";
            case HexDiagonal::NORTH_WEST: return "NORTH_WEST";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, HexDiagonal> from_string<HexDiagonal>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, HexDiagonal());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::HexDiagonal::string_sizes.size(); ++i) {
            const auto& current = detail::HexDiagonal::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::HexDiagonal::string_offset_and_counts[i].first;
                count = detail::HexDiagonal::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::HexDiagonal::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::HexDiagonal::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // NegativeTest1 Definition
    enum class NegativeTest1 : int8_t {
        A = -2,
        B = -1,
        C = 0,
        D = 1,
    };

    namespace detail { namespace NegativeTest1 {
        constexpr std::array<::enums::NegativeTest1, 4> values_arr =
        {{
            ::enums::NegativeTest1::A,
            ::enums::NegativeTest1::B,
            ::enums::NegativeTest1::C,
            ::enums::NegativeTest1::D,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            1,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 4),
        }};
        constexpr std::array<const char*, 4> enum_strings = {{
            "A",
            "B",
            "C",
            "D",
        }};
        constexpr std::array<::enums::NegativeTest1, 4> enum_string_values = {{
            ::enums::NegativeTest1::A,
            ::enums::NegativeTest1::B,
            ::enums::NegativeTest1::C,
            ::enums::NegativeTest1::D,
        }};
    }}

    template<>
    constexpr auto& values<NegativeTest1>()
    {
        return detail::NegativeTest1::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest1>(int8_t v) { return (-2 <= v) && (v <= 1); }

    constexpr const char* to_string(const NegativeTest1 v) {
        switch (v) {
            case NegativeTest1::A: return "A";
            case NegativeTest1::B: return "B";
            case NegativeTest1::C: return "C";
            case NegativeTest1::D: return "D";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, NegativeTest1> from_string<NegativeTest1>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, NegativeTest1());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::NegativeTest1::string_sizes.size(); ++i) {
            const auto& current = detail::NegativeTest1::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::NegativeTest1::string_offset_and_counts[i].first;
                count = detail::NegativeTest1::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::NegativeTest1::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::NegativeTest1::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // NegativeTest2 Definition
    enum class NegativeTest2 : int8_t {
        A = -3,
        B = -2,
        C = -1,
        D = 0,
    };

    namespace detail { namespace NegativeTest2 {
        constexpr std::array<::enums::NegativeTest2, 4> values_arr =
        {{
            ::enums::NegativeTest2::A,
            ::enums::NegativeTest2::B,
            ::enums::NegativeTest2::C,
            ::enums::NegativeTest2::D,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            1,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 4),
        }};
        constexpr std::array<const char*, 4> enum_strings = {{
            "A",
            "B",
            "C",
            "D",
        }};
        constexpr std::array<::enums::NegativeTest2, 4> enum_string_values = {{
            ::enums::NegativeTest2::A,
            ::enums::NegativeTest2::B,
            ::enums::NegativeTest2::C,
            ::enums::NegativeTest2::D,
        }};
    }}

    template<>
    constexpr auto& values<NegativeTest2>()
    {
        return detail::NegativeTest2::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest2>(int8_t v) { return (-3 <= v) && (v <= 0); }

    constexpr const char* to_string(const NegativeTest2 v) {
        switch (v) {
            case NegativeTest2::A: return "A";
            case NegativeTest2::B: return "B";
            case NegativeTest2::C: return "C";
            case NegativeTest2::D: return "D";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, NegativeTest2> from_string<NegativeTest2>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, NegativeTest2());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::NegativeTest2::string_sizes.size(); ++i) {
            const auto& current = detail::NegativeTest2::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::NegativeTest2::string_offset_and_counts[i].first;
                count = detail::NegativeTest2::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::NegativeTest2::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::NegativeTest2::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // NegativeTest3 Definition
    enum class NegativeTest3 : int8_t {
        A = -3,
        B = 4,
    };

    namespace detail { namespace NegativeTest3 {
        constexpr std::array<::enums::NegativeTest3, 2> values_arr =
        {{
            ::enums::NegativeTest3::A,
            ::enums::NegativeTest3::B,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            1,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
        }};
        constexpr std::array<const char*, 2> enum_strings = {{
            "A",
            "B",
        }};
        constexpr std::array<::enums::NegativeTest3, 2> enum_string_values = {{
            ::enums::NegativeTest3::A,
            ::enums::NegativeTest3::B,
        }};
    }}

    template<>
    constexpr auto& values<NegativeTest3>()
    {
        return detail::NegativeTest3::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest3>(int8_t v) {
        const NegativeTest3 test = static_cast<NegativeTest3>(v);
        for(std::size_t i = 0; i < values<NegativeTest3>().size(); i++) {
            const auto& val = values<NegativeTest3>()[i];
            if(val == static_cast<NegativeTest3>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const NegativeTest3 v) {
        switch (v) {
            case NegativeTest3::A: return "A";
            case NegativeTest3::B: return "B";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, NegativeTest3> from_string<NegativeTest3>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, NegativeTest3());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::NegativeTest3::string_sizes.size(); ++i) {
            const auto& current = detail::NegativeTest3::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::NegativeTest3::string_offset_and_counts[i].first;
                count = detail::NegativeTest3::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::NegativeTest3::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::NegativeTest3::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // NegativeTest4 Definition
    enum class NegativeTest4 : int8_t {
        A = -4,
        B = 3,
    };

    namespace detail { namespace NegativeTest4 {
        constexpr std::array<::enums::NegativeTest4, 2> values_arr =
        {{
            ::enums::NegativeTest4::A,
            ::enums::NegativeTest4::B,
        }};
        constexpr std::array<std::size_t, 1> string_sizes = {{
            1,
        }};
        constexpr std::array<std::pair<std::size_t, std::size_t>, 1> string_offset_and_counts = {{
            std::make_pair<std::size_t, std::size_t>(0, 2),
        }};
        constexpr std::array<const char*, 2> enum_strings = {{
            "A",
            "B",
        }};
        constexpr std::array<::enums::NegativeTest4, 2> enum_string_values = {{
            ::enums::NegativeTest4::A,
            ::enums::NegativeTest4::B,
        }};
    }}

    template<>
    constexpr auto& values<NegativeTest4>()
    {
        return detail::NegativeTest4::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest4>(int8_t v) {
        const NegativeTest4 test = static_cast<NegativeTest4>(v);
        for(std::size_t i = 0; i < values<NegativeTest4>().size(); i++) {
            const auto& val = values<NegativeTest4>()[i];
            if(val == static_cast<NegativeTest4>(test))
                return true;
        }
        return false;
    }

    constexpr const char* to_string(const NegativeTest4 v) {
        switch (v) {
            case NegativeTest4::A: return "A";
            case NegativeTest4::B: return "B";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, NegativeTest4> from_string<NegativeTest4>(const char* str, std::size_t len) {
        constexpr auto empty_val = std::make_pair(false, NegativeTest4());
        std::size_t offset = 0;
        std::size_t count = 0;
        for (std::size_t i = 0; i < detail::NegativeTest4::string_sizes.size(); ++i) {
            const auto& current = detail::NegativeTest4::string_sizes[i];
            if (current > len) { return empty_val; }
            if (current == len) { 
                offset = detail::NegativeTest4::string_offset_and_counts[i].first;
                count = detail::NegativeTest4::string_offset_and_counts[i].second;
                break;
            }
        }
        if (count == 0) { return empty_val; }

        for (std::size_t i = 0; i < count; ++i)
        {
            const auto& e_str = detail::NegativeTest4::enum_strings[offset + i];
            if (enumbra::detail::streq_known_size(e_str, str, len)) {
                return std::make_pair(true, detail::NegativeTest4::enum_string_values[offset + i]);
            }
        }

        return empty_val;
    }

    // EmptyTest1Unsigned Definition
    enum class EmptyTest1Unsigned : uint8_t {
        A = 0,
    };

    namespace detail { namespace EmptyTest1Unsigned {
        constexpr std::array<::enums::EmptyTest1Unsigned, 1> values_arr =
        {{
            ::enums::EmptyTest1Unsigned::A,
        }};
    }}

    template<>
    constexpr auto& values<EmptyTest1Unsigned>()
    {
        return detail::EmptyTest1Unsigned::values_arr;
    }

    template<>
    constexpr bool is_valid<EmptyTest1Unsigned>(uint8_t v) { return 0 == v; }

    constexpr const char* to_string(const EmptyTest1Unsigned v) {
        switch (v) {
            case EmptyTest1Unsigned::A: return "A";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, EmptyTest1Unsigned> from_string<EmptyTest1Unsigned>(const char* str, std::size_t len) {
        if (enumbra::detail::streq_s("A", 1, str, len)) {
            return std::make_pair(true, EmptyTest1Unsigned::A);
        }
        return std::make_pair(false, EmptyTest1Unsigned());
    }

    // EmptyTest1Signed Definition
    enum class EmptyTest1Signed : int8_t {
        A = 0,
    };

    namespace detail { namespace EmptyTest1Signed {
        constexpr std::array<::enums::EmptyTest1Signed, 1> values_arr =
        {{
            ::enums::EmptyTest1Signed::A,
        }};
    }}

    template<>
    constexpr auto& values<EmptyTest1Signed>()
    {
        return detail::EmptyTest1Signed::values_arr;
    }

    template<>
    constexpr bool is_valid<EmptyTest1Signed>(int8_t v) { return 0 == v; }

    constexpr const char* to_string(const EmptyTest1Signed v) {
        switch (v) {
            case EmptyTest1Signed::A: return "A";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, EmptyTest1Signed> from_string<EmptyTest1Signed>(const char* str, std::size_t len) {
        if (enumbra::detail::streq_s("A", 1, str, len)) {
            return std::make_pair(true, EmptyTest1Signed::A);
        }
        return std::make_pair(false, EmptyTest1Signed());
    }

    // SingleTest1Unsigned Definition
    enum class SingleTest1Unsigned : uint8_t {
        A = 4,
    };

    namespace detail { namespace SingleTest1Unsigned {
        constexpr std::array<::enums::SingleTest1Unsigned, 1> values_arr =
        {{
            ::enums::SingleTest1Unsigned::A,
        }};
    }}

    template<>
    constexpr auto& values<SingleTest1Unsigned>()
    {
        return detail::SingleTest1Unsigned::values_arr;
    }

    template<>
    constexpr bool is_valid<SingleTest1Unsigned>(uint8_t v) { return 4 == v; }

    constexpr const char* to_string(const SingleTest1Unsigned v) {
        switch (v) {
            case SingleTest1Unsigned::A: return "A";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, SingleTest1Unsigned> from_string<SingleTest1Unsigned>(const char* str, std::size_t len) {
        if (enumbra::detail::streq_s("A", 1, str, len)) {
            return std::make_pair(true, SingleTest1Unsigned::A);
        }
        return std::make_pair(false, SingleTest1Unsigned());
    }

    // SingleTest1Signed Definition
    enum class SingleTest1Signed : int8_t {
        A = 4,
    };

    namespace detail { namespace SingleTest1Signed {
        constexpr std::array<::enums::SingleTest1Signed, 1> values_arr =
        {{
            ::enums::SingleTest1Signed::A,
        }};
    }}

    template<>
    constexpr auto& values<SingleTest1Signed>()
    {
        return detail::SingleTest1Signed::values_arr;
    }

    template<>
    constexpr bool is_valid<SingleTest1Signed>(int8_t v) { return 4 == v; }

    constexpr const char* to_string(const SingleTest1Signed v) {
        switch (v) {
            case SingleTest1Signed::A: return "A";
        }
        return "";
    }

    template<>
    constexpr std::pair<bool, SingleTest1Signed> from_string<SingleTest1Signed>(const char* str, std::size_t len) {
        if (enumbra::detail::streq_s("A", 1, str, len)) {
            return std::make_pair(true, SingleTest1Signed::A);
        }
        return std::make_pair(false, SingleTest1Signed());
    }

    // test_flags Definition
    enum class test_flags : uint32_t {
        B = 1,
        C = 2,
    };

    namespace detail { namespace test_flags {
        constexpr std::array<::enums::test_flags, 2> flags_arr =
        {{
            ::enums::test_flags::B,
            ::enums::test_flags::C,
        }};
    } }

    template<>
    constexpr auto& flags<test_flags>()
    {
        return detail::test_flags::flags_arr;
    }

    constexpr void zero(test_flags& value) { value = static_cast<test_flags>(0); }
    constexpr bool test(test_flags value, test_flags flags) { return (static_cast<uint32_t>(flags) & static_cast<uint32_t>(value)) == static_cast<uint32_t>(flags); }
    constexpr void set(test_flags& value, test_flags flags) { value = static_cast<test_flags>(static_cast<uint32_t>(value) | static_cast<uint32_t>(flags)); }
    constexpr void unset(test_flags& value, test_flags flags) { value = static_cast<test_flags>(static_cast<uint32_t>(value) & (~static_cast<uint32_t>(flags))); }
    constexpr void toggle(test_flags& value, test_flags flags) { value = static_cast<test_flags>(static_cast<uint32_t>(value) ^ static_cast<uint32_t>(flags)); }
    constexpr bool is_all(test_flags value) { return static_cast<uint32_t>(value) >= 0x3; }
    constexpr bool is_any(test_flags value) { return static_cast<uint32_t>(value) > 0; }
    constexpr bool is_none(test_flags value) { return static_cast<uint32_t>(value) == 0; }
    constexpr bool is_single(test_flags value) { uint32_t n = static_cast<uint32_t>(value); return n && !(n & (n - 1)); }

    // test_flags Operator Overloads
    constexpr test_flags operator~(const test_flags a) { return static_cast<test_flags>(~static_cast<uint32_t>(a)); }
    constexpr test_flags operator|(const test_flags a, const test_flags b) { return static_cast<test_flags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
    constexpr test_flags operator&(const test_flags a, const test_flags b) { return static_cast<test_flags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
    constexpr test_flags operator^(const test_flags a, const test_flags b) { return static_cast<test_flags>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
    constexpr test_flags& operator|=(test_flags& a, const test_flags b) { a = a | b; return a; }
    constexpr test_flags& operator&=(test_flags& a, const test_flags b) { a = a & b; return a; }
    constexpr test_flags& operator^=(test_flags& a, const test_flags b) { a = a ^ b; return a; }

    // test_nodefault Definition
    enum class test_nodefault : uint16_t {
        B = 1,
        C = 2,
    };

    namespace detail { namespace test_nodefault {
        constexpr std::array<::enums::test_nodefault, 2> flags_arr =
        {{
            ::enums::test_nodefault::B,
            ::enums::test_nodefault::C,
        }};
    } }

    template<>
    constexpr auto& flags<test_nodefault>()
    {
        return detail::test_nodefault::flags_arr;
    }

    constexpr void zero(test_nodefault& value) { value = static_cast<test_nodefault>(0); }
    constexpr bool test(test_nodefault value, test_nodefault flags) { return (static_cast<uint16_t>(flags) & static_cast<uint16_t>(value)) == static_cast<uint16_t>(flags); }
    constexpr void set(test_nodefault& value, test_nodefault flags) { value = static_cast<test_nodefault>(static_cast<uint16_t>(value) | static_cast<uint16_t>(flags)); }
    constexpr void unset(test_nodefault& value, test_nodefault flags) { value = static_cast<test_nodefault>(static_cast<uint16_t>(value) & (~static_cast<uint16_t>(flags))); }
    constexpr void toggle(test_nodefault& value, test_nodefault flags) { value = static_cast<test_nodefault>(static_cast<uint16_t>(value) ^ static_cast<uint16_t>(flags)); }
    constexpr bool is_all(test_nodefault value) { return static_cast<uint16_t>(value) >= 0x3; }
    constexpr bool is_any(test_nodefault value) { return static_cast<uint16_t>(value) > 0; }
    constexpr bool is_none(test_nodefault value) { return static_cast<uint16_t>(value) == 0; }
    constexpr bool is_single(test_nodefault value) { uint16_t n = static_cast<uint16_t>(value); return n && !(n & (n - 1)); }

    // test_nodefault Operator Overloads
    constexpr test_nodefault operator~(const test_nodefault a) { return static_cast<test_nodefault>(~static_cast<uint16_t>(a)); }
    constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b) { return static_cast<test_nodefault>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
    constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b) { return static_cast<test_nodefault>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
    constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b) { return static_cast<test_nodefault>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
    constexpr test_nodefault& operator|=(test_nodefault& a, const test_nodefault b) { a = a | b; return a; }
    constexpr test_nodefault& operator&=(test_nodefault& a, const test_nodefault b) { a = a & b; return a; }
    constexpr test_nodefault& operator^=(test_nodefault& a, const test_nodefault b) { a = a ^ b; return a; }

    // TestSparseFlags Definition
    enum class TestSparseFlags : uint16_t {
        B = 1,
        C = 4,
        D = 16,
    };

    namespace detail { namespace TestSparseFlags {
        constexpr std::array<::enums::TestSparseFlags, 3> flags_arr =
        {{
            ::enums::TestSparseFlags::B,
            ::enums::TestSparseFlags::C,
            ::enums::TestSparseFlags::D,
        }};
    } }

    template<>
    constexpr auto& flags<TestSparseFlags>()
    {
        return detail::TestSparseFlags::flags_arr;
    }

    constexpr void zero(TestSparseFlags& value) { value = static_cast<TestSparseFlags>(0); }
    constexpr bool test(TestSparseFlags value, TestSparseFlags flags) { return (static_cast<uint16_t>(flags) & static_cast<uint16_t>(value)) == static_cast<uint16_t>(flags); }
    constexpr void set(TestSparseFlags& value, TestSparseFlags flags) { value = static_cast<TestSparseFlags>(static_cast<uint16_t>(value) | static_cast<uint16_t>(flags)); }
    constexpr void unset(TestSparseFlags& value, TestSparseFlags flags) { value = static_cast<TestSparseFlags>(static_cast<uint16_t>(value) & (~static_cast<uint16_t>(flags))); }
    constexpr void toggle(TestSparseFlags& value, TestSparseFlags flags) { value = static_cast<TestSparseFlags>(static_cast<uint16_t>(value) ^ static_cast<uint16_t>(flags)); }
    constexpr bool is_all(TestSparseFlags value) { return static_cast<uint16_t>(value) >= 0x15; }
    constexpr bool is_any(TestSparseFlags value) { return static_cast<uint16_t>(value) > 0; }
    constexpr bool is_none(TestSparseFlags value) { return static_cast<uint16_t>(value) == 0; }
    constexpr bool is_single(TestSparseFlags value) { uint16_t n = static_cast<uint16_t>(value); return n && !(n & (n - 1)); }

    // TestSparseFlags Operator Overloads
    constexpr TestSparseFlags operator~(const TestSparseFlags a) { return static_cast<TestSparseFlags>(~static_cast<uint16_t>(a)); }
    constexpr TestSparseFlags operator|(const TestSparseFlags a, const TestSparseFlags b) { return static_cast<TestSparseFlags>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
    constexpr TestSparseFlags operator&(const TestSparseFlags a, const TestSparseFlags b) { return static_cast<TestSparseFlags>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
    constexpr TestSparseFlags operator^(const TestSparseFlags a, const TestSparseFlags b) { return static_cast<TestSparseFlags>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
    constexpr TestSparseFlags& operator|=(TestSparseFlags& a, const TestSparseFlags b) { a = a | b; return a; }
    constexpr TestSparseFlags& operator&=(TestSparseFlags& a, const TestSparseFlags b) { a = a & b; return a; }
    constexpr TestSparseFlags& operator^=(TestSparseFlags& a, const TestSparseFlags b) { a = a ^ b; return a; }

    // TestSingleFlag Definition
    enum class TestSingleFlag : uint16_t {
        C = 4,
    };

    namespace detail { namespace TestSingleFlag {
        constexpr std::array<::enums::TestSingleFlag, 1> flags_arr =
        {{
            ::enums::TestSingleFlag::C,
        }};
    } }

    template<>
    constexpr auto& flags<TestSingleFlag>()
    {
        return detail::TestSingleFlag::flags_arr;
    }

    constexpr void zero(TestSingleFlag& value) { value = static_cast<TestSingleFlag>(0); }
    constexpr bool test(TestSingleFlag value, TestSingleFlag flags) { return (static_cast<uint16_t>(flags) & static_cast<uint16_t>(value)) == static_cast<uint16_t>(flags); }
    constexpr void set(TestSingleFlag& value, TestSingleFlag flags) { value = static_cast<TestSingleFlag>(static_cast<uint16_t>(value) | static_cast<uint16_t>(flags)); }
    constexpr void unset(TestSingleFlag& value, TestSingleFlag flags) { value = static_cast<TestSingleFlag>(static_cast<uint16_t>(value) & (~static_cast<uint16_t>(flags))); }
    constexpr void toggle(TestSingleFlag& value, TestSingleFlag flags) { value = static_cast<TestSingleFlag>(static_cast<uint16_t>(value) ^ static_cast<uint16_t>(flags)); }
    constexpr bool is_all(TestSingleFlag value) { return static_cast<uint16_t>(value) >= 0x4; }
    constexpr bool is_any(TestSingleFlag value) { return static_cast<uint16_t>(value) > 0; }
    constexpr bool is_none(TestSingleFlag value) { return static_cast<uint16_t>(value) == 0; }
    constexpr bool is_single(TestSingleFlag value) { uint16_t n = static_cast<uint16_t>(value); return n && !(n & (n - 1)); }

    // TestSingleFlag Operator Overloads
    constexpr TestSingleFlag operator~(const TestSingleFlag a) { return static_cast<TestSingleFlag>(~static_cast<uint16_t>(a)); }
    constexpr TestSingleFlag operator|(const TestSingleFlag a, const TestSingleFlag b) { return static_cast<TestSingleFlag>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
    constexpr TestSingleFlag operator&(const TestSingleFlag a, const TestSingleFlag b) { return static_cast<TestSingleFlag>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
    constexpr TestSingleFlag operator^(const TestSingleFlag a, const TestSingleFlag b) { return static_cast<TestSingleFlag>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
    constexpr TestSingleFlag& operator|=(TestSingleFlag& a, const TestSingleFlag b) { a = a | b; return a; }
    constexpr TestSingleFlag& operator&=(TestSingleFlag& a, const TestSingleFlag b) { a = a & b; return a; }
    constexpr TestSingleFlag& operator^=(TestSingleFlag& a, const TestSingleFlag b) { a = a ^ b; return a; }

} // namespace enums

// Template Specializations Begin
template<> struct enumbra::detail::base_helper<enums::test_string_parse> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Unsigned64Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed64Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed32Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed16Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed8Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::test_value> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::HexDiagonal> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest1> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest2> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest3> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest4> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Unsigned> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Signed> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Unsigned> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Signed> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::test_flags> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::base_helper<enums::test_nodefault> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::base_helper<enums::TestSparseFlags> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::base_helper<enums::TestSingleFlag> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_string_parse> : enumbra::detail::value_enum_info<int64_t, -1, 9223372036854775807, -1, int, 5, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Unsigned64Test> : enumbra::detail::value_enum_info<uint64_t, 0, 0xFFFFFFFFFFFFFFFF, 0, int, 4, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed64Test> : enumbra::detail::value_enum_info<int64_t, (-9223372036854775807 - 1), 9223372036854775807, (-9223372036854775807 - 1), int, 3, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed32Test> : enumbra::detail::value_enum_info<int32_t, (-2147483647 - 1), 2147483647, (-2147483647 - 1), int, 3, false, 32, 32> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed16Test> : enumbra::detail::value_enum_info<int16_t, (-32767 - 1), 32767, (-32767 - 1), int, 3, false, 16, 16> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed8Test> : enumbra::detail::value_enum_info<int8_t, (-127 - 1), 127, (-127 - 1), int, 3, false, 8, 8> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_value> : enumbra::detail::value_enum_info<int32_t, 0, 2, 0, int, 3, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::HexDiagonal> : enumbra::detail::value_enum_info<uint8_t, 0, 5, 0, int, 6, true, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest1> : enumbra::detail::value_enum_info<int8_t, -2, 1, -2, int, 4, true, 2, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest2> : enumbra::detail::value_enum_info<int8_t, -3, 0, -3, int, 4, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest3> : enumbra::detail::value_enum_info<int8_t, -3, 4, -3, int, 2, false, 4, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest4> : enumbra::detail::value_enum_info<int8_t, -4, 3, -4, int, 2, false, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Unsigned> : enumbra::detail::value_enum_info<uint8_t, 0, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Signed> : enumbra::detail::value_enum_info<int8_t, 0, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Unsigned> : enumbra::detail::value_enum_info<uint8_t, 4, 4, 4, int, 1, true, 3, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Signed> : enumbra::detail::value_enum_info<int8_t, 4, 4, 4, int, 1, true, 4, 0> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_flags> : enumbra::detail::flags_enum_info<uint32_t, 0, 3, 0, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_nodefault> : enumbra::detail::flags_enum_info<uint16_t, 0, 3, 0, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSparseFlags> : enumbra::detail::flags_enum_info<uint16_t, 0, 21, 0, int, 3, false, 5, 5> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSingleFlag> : enumbra::detail::flags_enum_info<uint16_t, 0, 4, 0, int, 1, true, 3, 3> { };
// Template Specializations End
