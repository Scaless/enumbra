// THIS FILE WAS GENERATED BY A TOOL
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated.
// You can support: https://github.com/Scaless/enumbra
// Generated by enumbra v0.2.0

// You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should put it in your enumbra_config.json file!

#pragma once

#include <cstdint>

#if !defined(ENUMBRA_REQUIRED_MACROS_VERSION) 
#define ENUMBRA_REQUIRED_MACROS_VERSION 8

// Find out what language version we're using
// 2024-07-04:MSVC Doesn't officially support C++23 yet
#if (__cplusplus >= 202302L)
#define ENUMBRA_CPP_VERSION 23
#elif ((defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)) || (__cplusplus >= 202002L)
#define ENUMBRA_CPP_VERSION 20
#elif ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)) || (__cplusplus >= 201703L)
#define ENUMBRA_CPP_VERSION 17
#else
#error Headers generated by enumbra require a compiler that supports C++17 or higher.
#endif

#if defined(__clang__)
#define ENUMBRA_COMPILER_CLANG
#elif defined(__GNUG__)
#define ENUMBRA_COMPILER_GCC
#elif defined(_MSC_VER)
#define ENUMBRA_COMPILER_MSVC
#else
#define ENUMBRA_COMPILER_UNKNOWN
#endif

#if defined(ENUMBRA_USER_UNREACHABLE)
#define ENUMBRA_UNREACHABLE ENUMBRA_USER_UNREACHABLE
#else
#define ENUMBRA_UNREACHABLE
#endif

#else // check existing version supported
#if (ENUMBRA_REQUIRED_MACROS_VERSION + 0) == 0 
#error ENUMBRA_REQUIRED_MACROS_VERSION has been defined without a proper version number. Check your build system. 
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) < 8 
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version. 
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) > 8 
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version. 
#endif // end check existing version supported
#endif // ENUMBRA_REQUIRED_MACROS_VERSION

#if !defined(ENUMBRA_OPTIONAL_MACROS_VERSION)
#define ENUMBRA_OPTIONAL_MACROS_VERSION 6

// Bitfield convenience functions
#define ENUMBRA_ZERO(Field) { decltype(Field) _field_ = Field; zero(_field_); Field = _field_; }
#define ENUMBRA_SET(Field, Value) { decltype(Field) _field_ = Field; set(_field_, Value); Field = _field_; }
#define ENUMBRA_UNSET(Field, Value) { decltype(Field) _field_ = Field; unset(_field_, Value); Field = _field_; }
#define ENUMBRA_TOGGLE(Field, Value) { decltype(Field) _field_ = Field; toggle(_field_, Value); Field = _field_; }

// Bit field storage helper
#define ENUMBRA_PACK_UNINITIALIZED(Enum, Name) Enum Name : ::enumbra::bits_required_storage<Enum>();
#define ENUMBRA_INIT(Name, InitValue) Name(::enumbra::default_value<decltype(Name)>())
#define ENUMBRA_INIT_DEFAULT(Name) Name(::enumbra::default_value<decltype(Name)>())

#if ENUMBRA_CPP_VERSION >= 20
// Bit field storage helper with type-checked member initialization
#define ENUMBRA_PACK_INIT(Enum, Name, InitValue) Enum Name : ::enumbra::bits_required_storage<Enum>() { InitValue };
// Bit field storage helper with default value initialization
#define ENUMBRA_PACK_INIT_DEFAULT(Enum, Name) Enum Name : ::enumbra::bits_required_storage<Enum>() { ::enumbra::default_value<Enum>() };
#endif

#else // check existing version supported
#if (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) == 0
#error ENUMBRA_OPTIONAL_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) < 6
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) > 6
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_OPTIONAL_MACROS_VERSION

#if !defined(ENUMBRA_BASE_TEMPLATES_VERSION)
#define ENUMBRA_BASE_TEMPLATES_VERSION 13
namespace enumbra {
    namespace detail {
        // Re-Implementation of std:: features to avoid including std headers
        template<bool B, class T = void>
        struct enable_if {};
        template<class T>
        struct enable_if<true, T> { typedef T type; };

        // Type info
        template<bool is_enumbra, bool is_value_enum, bool is_flags_enum>
        struct type_info { 
            static constexpr bool enumbra_type = is_enumbra;
            static constexpr bool enumbra_value_enum = is_value_enum;
            static constexpr bool enumbra_flags_enum = is_flags_enum;
        };

        // Value enum info
        template<typename underlying_type, underlying_type min_v, underlying_type max_v,
            underlying_type default_v, typename count_type, count_type count_v,
            bool is_contiguous_v, int bits_required_storage_v, int bits_required_transmission_v>
        struct value_enum_info {
            using underlying_t = underlying_type;
            static constexpr underlying_type min = min_v;
            static constexpr underlying_type max = max_v;
            static constexpr underlying_type def = default_v;
            static constexpr count_type count = count_v;
            static constexpr bool is_contiguous = is_contiguous_v;
            static constexpr int bits_required_storage = bits_required_storage_v;
            static constexpr int bits_required_transmission = bits_required_transmission_v;
        };

        // Flags enum info
        template<typename underlying_type, underlying_type min_v, underlying_type max_v, 
            underlying_type default_v, typename count_type, count_type count_v,
            bool is_contiguous_v, int bits_required_storage_v, int bits_required_transmission_v>
        struct flags_enum_info {
            using underlying_t = underlying_type;
            static constexpr underlying_type min = min_v;
            static constexpr underlying_type max = max_v;
            static constexpr underlying_type default_value = default_v;
            static constexpr count_type count = count_v;
            static constexpr bool is_contiguous = is_contiguous_v;
            static constexpr int bits_required_storage = bits_required_storage_v;
            static constexpr int bits_required_transmission = bits_required_transmission_v;
        };
        
        // Default template for non-enumbra types
        template<class T>
        struct base_helper : type_info<false, false, false> { };
        template<class T>
        struct value_enum_helper;
        template<class T>
        struct flags_enum_helper;

        // Constexpr string compare
        constexpr bool streq_s(const char* a, ::std::uint32_t a_len, const char* b, ::std::uint32_t b_len) noexcept {
            if(a_len != b_len) { return false; }
            for(::std::uint32_t i = 0; i < a_len; ++i) { if(a[i] != b[i]) { return false; } }
            return true;
        }
        constexpr bool streq_known_size(const char* a, const char* b, ::std::uint32_t len) noexcept {
            for(::std::uint32_t i = 0; i < len; ++i) { if(a[i] != b[i]) { return false; } }
            return true;
        }
    } // end namespace enumbra::detail
    template<class T> constexpr bool is_enumbra_enum() noexcept { return detail::base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_enum(T) noexcept { return detail::base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_value_enum() noexcept { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_value_enum(T) noexcept { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum() noexcept { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_flags_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum(T) noexcept { return is_enumbra_enum<T>() && detail::base_helper<T>::enumbra_flags_enum; }
    
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr T min() noexcept { return static_cast<T>(detail::value_enum_helper<T>::min); }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr T min() noexcept { return static_cast<T>(detail::flags_enum_helper<T>::min); }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T min() noexcept = delete;

    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr T max() noexcept { return static_cast<T>(detail::value_enum_helper<T>::max); }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr T max() noexcept { return static_cast<T>(detail::flags_enum_helper<T>::max); }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T max() noexcept = delete;

    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr T default_value() noexcept { return static_cast<T>(detail::value_enum_helper<T>::default_value); }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr T default_value() noexcept { return static_cast<T>(detail::flags_enum_helper<T>::default_value); }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T default_value() noexcept = delete;

    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr int count() noexcept { return detail::value_enum_helper<T>::count; }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr int count() noexcept { return detail::flags_enum_helper<T>::count; }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr int count() noexcept = delete;

    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr bool is_contiguous() noexcept { return detail::value_enum_helper<T>::is_contiguous; }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr bool is_contiguous() noexcept { return detail::flags_enum_helper<T>::is_contiguous; }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr bool is_contiguous() noexcept = delete;

    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_storage() noexcept { return detail::value_enum_helper<T>::bits_required_storage; }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_storage() noexcept { return detail::flags_enum_helper<T>::bits_required_storage; }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_storage() noexcept = delete;

    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_transmission() noexcept { return detail::value_enum_helper<T>::bits_required_transmission; }
    template<class T, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_transmission() noexcept { return detail::flags_enum_helper<T>::bits_required_transmission; }
    template<class T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr int bits_required_transmission() noexcept = delete;

    template<class T, class underlying_type = typename detail::base_helper<T>::base_type, typename ::enumbra::detail::enable_if<is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T from_underlying_unsafe(underlying_type e) noexcept { return static_cast<T>(e); }
    template<class T, class underlying_type = typename detail::base_helper<T>::base_type, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr T from_underlying_unsafe(underlying_type e) noexcept = delete;

    template<class T, class underlying_type = typename detail::value_enum_helper<T>::underlying_t, typename ::enumbra::detail::enable_if<is_enumbra_value_enum<T>(), T>::type* = nullptr>
    constexpr underlying_type to_underlying(T e) noexcept { return static_cast<underlying_type>(e); }
    template<class T, class underlying_type = typename detail::flags_enum_helper<T>::underlying_t, typename ::enumbra::detail::enable_if<is_enumbra_flags_enum<T>(), T>::type* = nullptr>
    constexpr underlying_type to_underlying(T e) noexcept { return static_cast<underlying_type>(e); }
    template<class T, class underlying_type = T, typename ::enumbra::detail::enable_if<!is_enumbra_enum<T>(), T>::type* = nullptr>
    constexpr underlying_type to_underlying(T e) noexcept = delete;

    template<class T>
    struct from_string_result
    {
        bool success;
        T result;
    };
} // end namespace enumbra
#else // check existing version supported
#if (ENUMBRA_BASE_TEMPLATES_VERSION + 0) == 0
#error ENUMBRA_BASE_TEMPLATES_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) < 13
#error An included header was generated using a newer version of enumbra. Regenerate your headers using same version of enumbra.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) > 13
#error An included header was generated using an older version of enumbra. Regenerate your headers using same version of enumbra.
#endif // check existing version supported
#endif // ENUMBRA_BASE_TEMPLATES_VERSION

namespace enums {

    // Begin Default Templates
    template<class T>
    constexpr ::enumbra::from_string_result<T> from_string(const char* str, ::std::uint16_t len) noexcept = delete;

    template<class T>
    constexpr auto& values() noexcept = delete;

    template<class T>
    constexpr auto& flags() noexcept = delete;

    template<class T, class underlying_type = typename ::enumbra::detail::base_helper<T>::base_type>
    constexpr bool is_valid(underlying_type value) noexcept = delete;
    // End Default Templates

    // test_string_parse Definition
    enum class test_string_parse : int64_t {
        C = -1,
        B = 1,
        F = 341,
        D = 511,
        E = 9223372036854775807,
    };

    namespace detail::test_string_parse {
        constexpr ::enums::test_string_parse values_arr[5] =
        {
            ::enums::test_string_parse::C,
            ::enums::test_string_parse::B,
            ::enums::test_string_parse::F,
            ::enums::test_string_parse::D,
            ::enums::test_string_parse::E,
        };
        constexpr const char enum_strings[11] = {
            "C\0"
            "B\0"
            "F\0"
            "D\0"
            "E\0"
        };
    }

    template<>
    constexpr auto& values<test_string_parse>() noexcept
    {
        return detail::test_string_parse::values_arr;
    }

    template<>
    constexpr bool is_valid<test_string_parse>(int64_t v) noexcept {
        for(::std::uint32_t i = 0; i < 5; i++) {
            if(values<test_string_parse>()[i] == static_cast<test_string_parse>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const test_string_parse v) noexcept {
        switch (v) {
            case test_string_parse::C: return &detail::test_string_parse::enum_strings[0];
            case test_string_parse::B: return &detail::test_string_parse::enum_strings[2];
            case test_string_parse::F: return &detail::test_string_parse::enum_strings[4];
            case test_string_parse::D: return &detail::test_string_parse::enum_strings[6];
            case test_string_parse::E: return &detail::test_string_parse::enum_strings[8];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<test_string_parse> from_string<test_string_parse>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, test_string_parse()}; }
        if(len != 1) { return {false, test_string_parse()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 5;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::test_string_parse::enum_strings + offset_str + i, str, len)) {
                return {true, detail::test_string_parse::values_arr[offset_enum]};
            }
        }
        return {false, test_string_parse()};
    }

    // Unsigned64Test Definition
    enum class Unsigned64Test : uint64_t {
        MIN = 0,
        V_UINT16_MAX = 0xFFFF,
        V_UINT32_MAX = 0xFFFFFFFF,
        MAX = 0xFFFFFFFFFFFFFFFF,
    };

    namespace detail::Unsigned64Test {
        constexpr ::enums::Unsigned64Test values_arr[4] =
        {
            ::enums::Unsigned64Test::MIN,
            ::enums::Unsigned64Test::V_UINT16_MAX,
            ::enums::Unsigned64Test::V_UINT32_MAX,
            ::enums::Unsigned64Test::MAX,
        };
        constexpr const char enum_strings[35] = {
            "MIN\0"
            "MAX\0"
            "V_UINT16_MAX\0"
            "V_UINT32_MAX\0"
        };
        constexpr ::enums::Unsigned64Test enum_string_values[4] = {
            ::enums::Unsigned64Test::MIN,
            ::enums::Unsigned64Test::MAX,
            ::enums::Unsigned64Test::V_UINT16_MAX,
            ::enums::Unsigned64Test::V_UINT32_MAX,
        };
    }

    template<>
    constexpr auto& values<Unsigned64Test>() noexcept
    {
        return detail::Unsigned64Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Unsigned64Test>(uint64_t v) noexcept {
        for(::std::uint32_t i = 0; i < 4; i++) {
            if(values<Unsigned64Test>()[i] == static_cast<Unsigned64Test>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const Unsigned64Test v) noexcept {
        switch (v) {
            case Unsigned64Test::MIN: return &detail::Unsigned64Test::enum_strings[0];
            case Unsigned64Test::MAX: return &detail::Unsigned64Test::enum_strings[4];
            case Unsigned64Test::V_UINT16_MAX: return &detail::Unsigned64Test::enum_strings[8];
            case Unsigned64Test::V_UINT32_MAX: return &detail::Unsigned64Test::enum_strings[21];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<Unsigned64Test> from_string<Unsigned64Test>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, Unsigned64Test()}; }
        ::std::uint32_t offset_str = 0;
        ::std::uint32_t offset_enum = 0;
        ::std::uint32_t count = 0;
        switch(len)
        {
            case 3: offset_str = 0; offset_enum = 0; count = 2; break;
            case 12: offset_str = 8; offset_enum = 1; count = 2; break;
            default: return {false, Unsigned64Test()};
        }
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::Unsigned64Test::enum_strings + offset_str + i, str, len)) {
                return {true, detail::Unsigned64Test::enum_string_values[offset_enum]};
            }
        }
        return {false, Unsigned64Test()};
    }

    // Signed64Test Definition
    enum class Signed64Test : int64_t {
        MIN = (-9223372036854775807 - 1),
        NEG_ONE = -1,
        MAX = 9223372036854775807,
    };

    namespace detail::Signed64Test {
        constexpr ::enums::Signed64Test values_arr[3] =
        {
            ::enums::Signed64Test::MIN,
            ::enums::Signed64Test::NEG_ONE,
            ::enums::Signed64Test::MAX,
        };
        constexpr const char enum_strings[17] = {
            "MIN\0"
            "MAX\0"
            "NEG_ONE\0"
        };
        constexpr ::enums::Signed64Test enum_string_values[3] = {
            ::enums::Signed64Test::MIN,
            ::enums::Signed64Test::MAX,
            ::enums::Signed64Test::NEG_ONE,
        };
    }

    template<>
    constexpr auto& values<Signed64Test>() noexcept
    {
        return detail::Signed64Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed64Test>(int64_t v) noexcept {
        for(::std::uint32_t i = 0; i < 3; i++) {
            if(values<Signed64Test>()[i] == static_cast<Signed64Test>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const Signed64Test v) noexcept {
        switch (v) {
            case Signed64Test::MIN: return &detail::Signed64Test::enum_strings[0];
            case Signed64Test::MAX: return &detail::Signed64Test::enum_strings[4];
            case Signed64Test::NEG_ONE: return &detail::Signed64Test::enum_strings[8];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<Signed64Test> from_string<Signed64Test>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, Signed64Test()}; }
        ::std::uint32_t offset_str = 0;
        ::std::uint32_t offset_enum = 0;
        ::std::uint32_t count = 0;
        switch(len)
        {
            case 3: offset_str = 0; offset_enum = 0; count = 2; break;
            case 7: offset_str = 8; offset_enum = 1; count = 1; break;
            default: return {false, Signed64Test()};
        }
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::Signed64Test::enum_strings + offset_str + i, str, len)) {
                return {true, detail::Signed64Test::enum_string_values[offset_enum]};
            }
        }
        return {false, Signed64Test()};
    }

    // Signed32Test Definition
    enum class Signed32Test : int32_t {
        MIN = (-2147483647 - 1),
        NEG_ONE = -1,
        MAX = 2147483647,
    };

    namespace detail::Signed32Test {
        constexpr ::enums::Signed32Test values_arr[3] =
        {
            ::enums::Signed32Test::MIN,
            ::enums::Signed32Test::NEG_ONE,
            ::enums::Signed32Test::MAX,
        };
        constexpr const char enum_strings[17] = {
            "MIN\0"
            "MAX\0"
            "NEG_ONE\0"
        };
        constexpr ::enums::Signed32Test enum_string_values[3] = {
            ::enums::Signed32Test::MIN,
            ::enums::Signed32Test::MAX,
            ::enums::Signed32Test::NEG_ONE,
        };
    }

    template<>
    constexpr auto& values<Signed32Test>() noexcept
    {
        return detail::Signed32Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed32Test>(int32_t v) noexcept {
        for(::std::uint32_t i = 0; i < 3; i++) {
            if(values<Signed32Test>()[i] == static_cast<Signed32Test>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const Signed32Test v) noexcept {
        switch (v) {
            case Signed32Test::MIN: return &detail::Signed32Test::enum_strings[0];
            case Signed32Test::MAX: return &detail::Signed32Test::enum_strings[4];
            case Signed32Test::NEG_ONE: return &detail::Signed32Test::enum_strings[8];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<Signed32Test> from_string<Signed32Test>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, Signed32Test()}; }
        ::std::uint32_t offset_str = 0;
        ::std::uint32_t offset_enum = 0;
        ::std::uint32_t count = 0;
        switch(len)
        {
            case 3: offset_str = 0; offset_enum = 0; count = 2; break;
            case 7: offset_str = 8; offset_enum = 1; count = 1; break;
            default: return {false, Signed32Test()};
        }
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::Signed32Test::enum_strings + offset_str + i, str, len)) {
                return {true, detail::Signed32Test::enum_string_values[offset_enum]};
            }
        }
        return {false, Signed32Test()};
    }

    // Signed16Test Definition
    enum class Signed16Test : int16_t {
        MIN = (-32767 - 1),
        NEG_ONE = -1,
        MAX = 32767,
    };

    namespace detail::Signed16Test {
        constexpr ::enums::Signed16Test values_arr[3] =
        {
            ::enums::Signed16Test::MIN,
            ::enums::Signed16Test::NEG_ONE,
            ::enums::Signed16Test::MAX,
        };
        constexpr const char enum_strings[17] = {
            "MIN\0"
            "MAX\0"
            "NEG_ONE\0"
        };
        constexpr ::enums::Signed16Test enum_string_values[3] = {
            ::enums::Signed16Test::MIN,
            ::enums::Signed16Test::MAX,
            ::enums::Signed16Test::NEG_ONE,
        };
    }

    template<>
    constexpr auto& values<Signed16Test>() noexcept
    {
        return detail::Signed16Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed16Test>(int16_t v) noexcept {
        for(::std::uint32_t i = 0; i < 3; i++) {
            if(values<Signed16Test>()[i] == static_cast<Signed16Test>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const Signed16Test v) noexcept {
        switch (v) {
            case Signed16Test::MIN: return &detail::Signed16Test::enum_strings[0];
            case Signed16Test::MAX: return &detail::Signed16Test::enum_strings[4];
            case Signed16Test::NEG_ONE: return &detail::Signed16Test::enum_strings[8];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<Signed16Test> from_string<Signed16Test>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, Signed16Test()}; }
        ::std::uint32_t offset_str = 0;
        ::std::uint32_t offset_enum = 0;
        ::std::uint32_t count = 0;
        switch(len)
        {
            case 3: offset_str = 0; offset_enum = 0; count = 2; break;
            case 7: offset_str = 8; offset_enum = 1; count = 1; break;
            default: return {false, Signed16Test()};
        }
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::Signed16Test::enum_strings + offset_str + i, str, len)) {
                return {true, detail::Signed16Test::enum_string_values[offset_enum]};
            }
        }
        return {false, Signed16Test()};
    }

    // Signed8Test Definition
    enum class Signed8Test : int8_t {
        V_INT_MIN = (-127 - 1),
        V_NEG_ONE = -1,
        V_INT_MAX = 127,
    };

    namespace detail::Signed8Test {
        constexpr ::enums::Signed8Test values_arr[3] =
        {
            ::enums::Signed8Test::V_INT_MIN,
            ::enums::Signed8Test::V_NEG_ONE,
            ::enums::Signed8Test::V_INT_MAX,
        };
        constexpr const char enum_strings[31] = {
            "V_INT_MIN\0"
            "V_NEG_ONE\0"
            "V_INT_MAX\0"
        };
    }

    template<>
    constexpr auto& values<Signed8Test>() noexcept
    {
        return detail::Signed8Test::values_arr;
    }

    template<>
    constexpr bool is_valid<Signed8Test>(int8_t v) noexcept {
        for(::std::uint32_t i = 0; i < 3; i++) {
            if(values<Signed8Test>()[i] == static_cast<Signed8Test>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const Signed8Test v) noexcept {
        switch (v) {
            case Signed8Test::V_INT_MIN: return &detail::Signed8Test::enum_strings[0];
            case Signed8Test::V_NEG_ONE: return &detail::Signed8Test::enum_strings[10];
            case Signed8Test::V_INT_MAX: return &detail::Signed8Test::enum_strings[20];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<Signed8Test> from_string<Signed8Test>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, Signed8Test()}; }
        if(len != 9) { return {false, Signed8Test()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 3;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::Signed8Test::enum_strings + offset_str + i, str, len)) {
                return {true, detail::Signed8Test::values_arr[offset_enum]};
            }
        }
        return {false, Signed8Test()};
    }

    // test_value Definition
    enum class test_value : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    namespace detail::test_value {
        constexpr ::enums::test_value values_arr[3] =
        {
            ::enums::test_value::A,
            ::enums::test_value::B,
            ::enums::test_value::C,
        };
        constexpr const char enum_strings[7] = {
            "A\0"
            "B\0"
            "C\0"
        };
    }

    template<>
    constexpr auto& values<test_value>() noexcept
    {
        return detail::test_value::values_arr;
    }

    template<>
    constexpr bool is_valid<test_value>(int32_t v) noexcept { return (0 <= v) && (v <= 2); }

    constexpr const char* to_string(const test_value v) noexcept {
        switch (v) {
            case test_value::A: return &detail::test_value::enum_strings[0];
            case test_value::B: return &detail::test_value::enum_strings[2];
            case test_value::C: return &detail::test_value::enum_strings[4];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<test_value> from_string<test_value>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, test_value()}; }
        if(len != 1) { return {false, test_value()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 3;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::test_value::enum_strings + offset_str + i, str, len)) {
                return {true, detail::test_value::values_arr[offset_enum]};
            }
        }
        return {false, test_value()};
    }

    // HexDiagonal Definition
    enum class HexDiagonal : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    namespace detail::HexDiagonal {
        constexpr ::enums::HexDiagonal values_arr[6] =
        {
            ::enums::HexDiagonal::NORTH,
            ::enums::HexDiagonal::NORTH_EAST,
            ::enums::HexDiagonal::SOUTH_EAST,
            ::enums::HexDiagonal::SOUTH,
            ::enums::HexDiagonal::SOUTH_WEST,
            ::enums::HexDiagonal::NORTH_WEST,
        };
        constexpr const char enum_strings[57] = {
            "NORTH\0"
            "SOUTH\0"
            "NORTH_EAST\0"
            "SOUTH_EAST\0"
            "SOUTH_WEST\0"
            "NORTH_WEST\0"
        };
        constexpr ::enums::HexDiagonal enum_string_values[6] = {
            ::enums::HexDiagonal::NORTH,
            ::enums::HexDiagonal::SOUTH,
            ::enums::HexDiagonal::NORTH_EAST,
            ::enums::HexDiagonal::SOUTH_EAST,
            ::enums::HexDiagonal::SOUTH_WEST,
            ::enums::HexDiagonal::NORTH_WEST,
        };
    }

    template<>
    constexpr auto& values<HexDiagonal>() noexcept
    {
        return detail::HexDiagonal::values_arr;
    }

    template<>
    constexpr bool is_valid<HexDiagonal>(uint8_t v) noexcept { return v <= 5; }

    constexpr const char* to_string(const HexDiagonal v) noexcept {
        switch (v) {
            case HexDiagonal::NORTH: return &detail::HexDiagonal::enum_strings[0];
            case HexDiagonal::SOUTH: return &detail::HexDiagonal::enum_strings[6];
            case HexDiagonal::NORTH_EAST: return &detail::HexDiagonal::enum_strings[12];
            case HexDiagonal::SOUTH_EAST: return &detail::HexDiagonal::enum_strings[23];
            case HexDiagonal::SOUTH_WEST: return &detail::HexDiagonal::enum_strings[34];
            case HexDiagonal::NORTH_WEST: return &detail::HexDiagonal::enum_strings[45];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<HexDiagonal> from_string<HexDiagonal>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, HexDiagonal()}; }
        ::std::uint32_t offset_str = 0;
        ::std::uint32_t offset_enum = 0;
        ::std::uint32_t count = 0;
        switch(len)
        {
            case 5: offset_str = 0; offset_enum = 0; count = 2; break;
            case 10: offset_str = 12; offset_enum = 1; count = 4; break;
            default: return {false, HexDiagonal()};
        }
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::HexDiagonal::enum_strings + offset_str + i, str, len)) {
                return {true, detail::HexDiagonal::enum_string_values[offset_enum]};
            }
        }
        return {false, HexDiagonal()};
    }

    // NegativeTest1 Definition
    enum class NegativeTest1 : int8_t {
        A = -2,
        B = -1,
        C = 0,
        D = 1,
    };

    namespace detail::NegativeTest1 {
        constexpr ::enums::NegativeTest1 values_arr[4] =
        {
            ::enums::NegativeTest1::A,
            ::enums::NegativeTest1::B,
            ::enums::NegativeTest1::C,
            ::enums::NegativeTest1::D,
        };
        constexpr const char enum_strings[9] = {
            "A\0"
            "B\0"
            "C\0"
            "D\0"
        };
    }

    template<>
    constexpr auto& values<NegativeTest1>() noexcept
    {
        return detail::NegativeTest1::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest1>(int8_t v) noexcept { return (-2 <= v) && (v <= 1); }

    constexpr const char* to_string(const NegativeTest1 v) noexcept {
        switch (v) {
            case NegativeTest1::A: return &detail::NegativeTest1::enum_strings[0];
            case NegativeTest1::B: return &detail::NegativeTest1::enum_strings[2];
            case NegativeTest1::C: return &detail::NegativeTest1::enum_strings[4];
            case NegativeTest1::D: return &detail::NegativeTest1::enum_strings[6];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<NegativeTest1> from_string<NegativeTest1>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, NegativeTest1()}; }
        if(len != 1) { return {false, NegativeTest1()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 4;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::NegativeTest1::enum_strings + offset_str + i, str, len)) {
                return {true, detail::NegativeTest1::values_arr[offset_enum]};
            }
        }
        return {false, NegativeTest1()};
    }

    // NegativeTest2 Definition
    enum class NegativeTest2 : int8_t {
        A = -3,
        B = -2,
        C = -1,
        D = 0,
    };

    namespace detail::NegativeTest2 {
        constexpr ::enums::NegativeTest2 values_arr[4] =
        {
            ::enums::NegativeTest2::A,
            ::enums::NegativeTest2::B,
            ::enums::NegativeTest2::C,
            ::enums::NegativeTest2::D,
        };
        constexpr const char enum_strings[9] = {
            "A\0"
            "B\0"
            "C\0"
            "D\0"
        };
    }

    template<>
    constexpr auto& values<NegativeTest2>() noexcept
    {
        return detail::NegativeTest2::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest2>(int8_t v) noexcept { return (-3 <= v) && (v <= 0); }

    constexpr const char* to_string(const NegativeTest2 v) noexcept {
        switch (v) {
            case NegativeTest2::A: return &detail::NegativeTest2::enum_strings[0];
            case NegativeTest2::B: return &detail::NegativeTest2::enum_strings[2];
            case NegativeTest2::C: return &detail::NegativeTest2::enum_strings[4];
            case NegativeTest2::D: return &detail::NegativeTest2::enum_strings[6];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<NegativeTest2> from_string<NegativeTest2>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, NegativeTest2()}; }
        if(len != 1) { return {false, NegativeTest2()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 4;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::NegativeTest2::enum_strings + offset_str + i, str, len)) {
                return {true, detail::NegativeTest2::values_arr[offset_enum]};
            }
        }
        return {false, NegativeTest2()};
    }

    // NegativeTest3 Definition
    enum class NegativeTest3 : int8_t {
        A = -3,
        B = 4,
    };

    namespace detail::NegativeTest3 {
        constexpr ::enums::NegativeTest3 values_arr[2] =
        {
            ::enums::NegativeTest3::A,
            ::enums::NegativeTest3::B,
        };
        constexpr const char enum_strings[5] = {
            "A\0"
            "B\0"
        };
    }

    template<>
    constexpr auto& values<NegativeTest3>() noexcept
    {
        return detail::NegativeTest3::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest3>(int8_t v) noexcept {
        for(::std::uint32_t i = 0; i < 2; i++) {
            if(values<NegativeTest3>()[i] == static_cast<NegativeTest3>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const NegativeTest3 v) noexcept {
        switch (v) {
            case NegativeTest3::A: return &detail::NegativeTest3::enum_strings[0];
            case NegativeTest3::B: return &detail::NegativeTest3::enum_strings[2];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<NegativeTest3> from_string<NegativeTest3>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, NegativeTest3()}; }
        if(len != 1) { return {false, NegativeTest3()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 2;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::NegativeTest3::enum_strings + offset_str + i, str, len)) {
                return {true, detail::NegativeTest3::values_arr[offset_enum]};
            }
        }
        return {false, NegativeTest3()};
    }

    // NegativeTest4 Definition
    enum class NegativeTest4 : int8_t {
        A = -4,
        B = 3,
    };

    namespace detail::NegativeTest4 {
        constexpr ::enums::NegativeTest4 values_arr[2] =
        {
            ::enums::NegativeTest4::A,
            ::enums::NegativeTest4::B,
        };
        constexpr const char enum_strings[5] = {
            "A\0"
            "B\0"
        };
    }

    template<>
    constexpr auto& values<NegativeTest4>() noexcept
    {
        return detail::NegativeTest4::values_arr;
    }

    template<>
    constexpr bool is_valid<NegativeTest4>(int8_t v) noexcept {
        for(::std::uint32_t i = 0; i < 2; i++) {
            if(values<NegativeTest4>()[i] == static_cast<NegativeTest4>(v)) { return true; }
        }
        return false;
    }

    constexpr const char* to_string(const NegativeTest4 v) noexcept {
        switch (v) {
            case NegativeTest4::A: return &detail::NegativeTest4::enum_strings[0];
            case NegativeTest4::B: return &detail::NegativeTest4::enum_strings[2];
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<NegativeTest4> from_string<NegativeTest4>(const char* str, ::std::uint16_t len) noexcept {
        if(str == nullptr) { return {false, NegativeTest4()}; }
        if(len != 1) { return {false, NegativeTest4()}; }
        constexpr ::std::uint32_t offset_str = 0;
        constexpr ::std::uint32_t offset_enum = 0;
        constexpr ::std::uint32_t count = 2;
        for (::std::uint32_t i = 0; i < (count * len); i += (len + 1)) {
            if (enumbra::detail::streq_known_size(detail::NegativeTest4::enum_strings + offset_str + i, str, len)) {
                return {true, detail::NegativeTest4::values_arr[offset_enum]};
            }
        }
        return {false, NegativeTest4()};
    }

    // EmptyTest1Unsigned Definition
    enum class EmptyTest1Unsigned : uint8_t {
        A = 0,
    };

    namespace detail::EmptyTest1Unsigned {
        constexpr ::enums::EmptyTest1Unsigned values_arr[1] =
        {
            ::enums::EmptyTest1Unsigned::A,
        };
    }

    template<>
    constexpr auto& values<EmptyTest1Unsigned>() noexcept
    {
        return detail::EmptyTest1Unsigned::values_arr;
    }

    template<>
    constexpr bool is_valid<EmptyTest1Unsigned>(uint8_t v) noexcept { return 0 == v; }

    constexpr const char* to_string(const EmptyTest1Unsigned v) noexcept {
        switch (v) {
            case EmptyTest1Unsigned::A: return "A";
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<EmptyTest1Unsigned> from_string<EmptyTest1Unsigned>(const char* str, ::std::uint16_t len) noexcept {
        if ((str != nullptr) && enumbra::detail::streq_s("A", 1, str, len)) {
            return {true, EmptyTest1Unsigned::A};
        }
        return {false, EmptyTest1Unsigned()};
    }

    // EmptyTest1Signed Definition
    enum class EmptyTest1Signed : int8_t {
        A = 0,
    };

    namespace detail::EmptyTest1Signed {
        constexpr ::enums::EmptyTest1Signed values_arr[1] =
        {
            ::enums::EmptyTest1Signed::A,
        };
    }

    template<>
    constexpr auto& values<EmptyTest1Signed>() noexcept
    {
        return detail::EmptyTest1Signed::values_arr;
    }

    template<>
    constexpr bool is_valid<EmptyTest1Signed>(int8_t v) noexcept { return 0 == v; }

    constexpr const char* to_string(const EmptyTest1Signed v) noexcept {
        switch (v) {
            case EmptyTest1Signed::A: return "A";
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<EmptyTest1Signed> from_string<EmptyTest1Signed>(const char* str, ::std::uint16_t len) noexcept {
        if ((str != nullptr) && enumbra::detail::streq_s("A", 1, str, len)) {
            return {true, EmptyTest1Signed::A};
        }
        return {false, EmptyTest1Signed()};
    }

    // SingleTest1Unsigned Definition
    enum class SingleTest1Unsigned : uint8_t {
        A = 4,
    };

    namespace detail::SingleTest1Unsigned {
        constexpr ::enums::SingleTest1Unsigned values_arr[1] =
        {
            ::enums::SingleTest1Unsigned::A,
        };
    }

    template<>
    constexpr auto& values<SingleTest1Unsigned>() noexcept
    {
        return detail::SingleTest1Unsigned::values_arr;
    }

    template<>
    constexpr bool is_valid<SingleTest1Unsigned>(uint8_t v) noexcept { return 4 == v; }

    constexpr const char* to_string(const SingleTest1Unsigned v) noexcept {
        switch (v) {
            case SingleTest1Unsigned::A: return "A";
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<SingleTest1Unsigned> from_string<SingleTest1Unsigned>(const char* str, ::std::uint16_t len) noexcept {
        if ((str != nullptr) && enumbra::detail::streq_s("A", 1, str, len)) {
            return {true, SingleTest1Unsigned::A};
        }
        return {false, SingleTest1Unsigned()};
    }

    // SingleTest1Signed Definition
    enum class SingleTest1Signed : int8_t {
        A = 4,
    };

    namespace detail::SingleTest1Signed {
        constexpr ::enums::SingleTest1Signed values_arr[1] =
        {
            ::enums::SingleTest1Signed::A,
        };
    }

    template<>
    constexpr auto& values<SingleTest1Signed>() noexcept
    {
        return detail::SingleTest1Signed::values_arr;
    }

    template<>
    constexpr bool is_valid<SingleTest1Signed>(int8_t v) noexcept { return 4 == v; }

    constexpr const char* to_string(const SingleTest1Signed v) noexcept {
        switch (v) {
            case SingleTest1Signed::A: return "A";
        }
        return nullptr;
    }

    template<>
    constexpr ::enumbra::from_string_result<SingleTest1Signed> from_string<SingleTest1Signed>(const char* str, ::std::uint16_t len) noexcept {
        if ((str != nullptr) && enumbra::detail::streq_s("A", 1, str, len)) {
            return {true, SingleTest1Signed::A};
        }
        return {false, SingleTest1Signed()};
    }

    // test_flags Definition
    enum class test_flags : uint32_t {
        B = 1,
        C = 2,
    };

    namespace detail::test_flags {
        constexpr ::enums::test_flags flags_arr[2] =
        {
            ::enums::test_flags::B,
            ::enums::test_flags::C,
        };
    }

    template<>
    constexpr auto& flags<test_flags>() noexcept
    {
        return detail::test_flags::flags_arr;
    }

    constexpr void zero(test_flags& value) noexcept { value = static_cast<test_flags>(0); }
    constexpr bool test(test_flags value, test_flags flags) noexcept { return (static_cast<uint32_t>(flags) & static_cast<uint32_t>(value)) == static_cast<uint32_t>(flags); }
    constexpr void set(test_flags& value, test_flags flags) noexcept { value = static_cast<test_flags>(static_cast<uint32_t>(value) | static_cast<uint32_t>(flags)); }
    constexpr void unset(test_flags& value, test_flags flags) noexcept { value = static_cast<test_flags>(static_cast<uint32_t>(value) & (~static_cast<uint32_t>(flags))); }
    constexpr void toggle(test_flags& value, test_flags flags) noexcept { value = static_cast<test_flags>(static_cast<uint32_t>(value) ^ static_cast<uint32_t>(flags)); }
    constexpr bool is_all(test_flags value) noexcept { return static_cast<uint32_t>(value) >= 0x3; }
    constexpr bool is_any(test_flags value) noexcept { return static_cast<uint32_t>(value) > 0; }
    constexpr bool is_none(test_flags value) noexcept { return static_cast<uint32_t>(value) == 0; }
    constexpr bool is_single(test_flags value) noexcept { uint32_t n = static_cast<uint32_t>(value); return n && !(n & (n - 1)); }

    // test_flags Operator Overloads
    constexpr test_flags operator~(const test_flags a) noexcept { return static_cast<test_flags>(~static_cast<uint32_t>(a)); }
    constexpr test_flags operator|(const test_flags a, const test_flags b) noexcept { return static_cast<test_flags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
    constexpr test_flags operator&(const test_flags a, const test_flags b) noexcept { return static_cast<test_flags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
    constexpr test_flags operator^(const test_flags a, const test_flags b) noexcept { return static_cast<test_flags>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
    constexpr test_flags& operator|=(test_flags& a, const test_flags b) noexcept { return a = a | b; }
    constexpr test_flags& operator&=(test_flags& a, const test_flags b) noexcept { return a = a & b; }
    constexpr test_flags& operator^=(test_flags& a, const test_flags b) noexcept { return a = a ^ b; }

    // test_nodefault Definition
    enum class test_nodefault : uint16_t {
        B = 1,
        C = 2,
    };

    namespace detail::test_nodefault {
        constexpr ::enums::test_nodefault flags_arr[2] =
        {
            ::enums::test_nodefault::B,
            ::enums::test_nodefault::C,
        };
    }

    template<>
    constexpr auto& flags<test_nodefault>() noexcept
    {
        return detail::test_nodefault::flags_arr;
    }

    constexpr void zero(test_nodefault& value) noexcept { value = static_cast<test_nodefault>(0); }
    constexpr bool test(test_nodefault value, test_nodefault flags) noexcept { return (static_cast<uint16_t>(flags) & static_cast<uint16_t>(value)) == static_cast<uint16_t>(flags); }
    constexpr void set(test_nodefault& value, test_nodefault flags) noexcept { value = static_cast<test_nodefault>(static_cast<uint16_t>(value) | static_cast<uint16_t>(flags)); }
    constexpr void unset(test_nodefault& value, test_nodefault flags) noexcept { value = static_cast<test_nodefault>(static_cast<uint16_t>(value) & (~static_cast<uint16_t>(flags))); }
    constexpr void toggle(test_nodefault& value, test_nodefault flags) noexcept { value = static_cast<test_nodefault>(static_cast<uint16_t>(value) ^ static_cast<uint16_t>(flags)); }
    constexpr bool is_all(test_nodefault value) noexcept { return static_cast<uint16_t>(value) >= 0x3; }
    constexpr bool is_any(test_nodefault value) noexcept { return static_cast<uint16_t>(value) > 0; }
    constexpr bool is_none(test_nodefault value) noexcept { return static_cast<uint16_t>(value) == 0; }
    constexpr bool is_single(test_nodefault value) noexcept { uint16_t n = static_cast<uint16_t>(value); return n && !(n & (n - 1)); }

    // test_nodefault Operator Overloads
    constexpr test_nodefault operator~(const test_nodefault a) noexcept { return static_cast<test_nodefault>(~static_cast<uint16_t>(a)); }
    constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b) noexcept { return static_cast<test_nodefault>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
    constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b) noexcept { return static_cast<test_nodefault>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
    constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b) noexcept { return static_cast<test_nodefault>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
    constexpr test_nodefault& operator|=(test_nodefault& a, const test_nodefault b) noexcept { return a = a | b; }
    constexpr test_nodefault& operator&=(test_nodefault& a, const test_nodefault b) noexcept { return a = a & b; }
    constexpr test_nodefault& operator^=(test_nodefault& a, const test_nodefault b) noexcept { return a = a ^ b; }

    // TestSparseFlags Definition
    enum class TestSparseFlags : uint16_t {
        B = 1,
        C = 4,
        D = 16,
    };

    namespace detail::TestSparseFlags {
        constexpr ::enums::TestSparseFlags flags_arr[3] =
        {
            ::enums::TestSparseFlags::B,
            ::enums::TestSparseFlags::C,
            ::enums::TestSparseFlags::D,
        };
    }

    template<>
    constexpr auto& flags<TestSparseFlags>() noexcept
    {
        return detail::TestSparseFlags::flags_arr;
    }

    constexpr void zero(TestSparseFlags& value) noexcept { value = static_cast<TestSparseFlags>(0); }
    constexpr bool test(TestSparseFlags value, TestSparseFlags flags) noexcept { return (static_cast<uint16_t>(flags) & static_cast<uint16_t>(value)) == static_cast<uint16_t>(flags); }
    constexpr void set(TestSparseFlags& value, TestSparseFlags flags) noexcept { value = static_cast<TestSparseFlags>(static_cast<uint16_t>(value) | static_cast<uint16_t>(flags)); }
    constexpr void unset(TestSparseFlags& value, TestSparseFlags flags) noexcept { value = static_cast<TestSparseFlags>(static_cast<uint16_t>(value) & (~static_cast<uint16_t>(flags))); }
    constexpr void toggle(TestSparseFlags& value, TestSparseFlags flags) noexcept { value = static_cast<TestSparseFlags>(static_cast<uint16_t>(value) ^ static_cast<uint16_t>(flags)); }
    constexpr bool is_all(TestSparseFlags value) noexcept { return static_cast<uint16_t>(value) >= 0x15; }
    constexpr bool is_any(TestSparseFlags value) noexcept { return static_cast<uint16_t>(value) > 0; }
    constexpr bool is_none(TestSparseFlags value) noexcept { return static_cast<uint16_t>(value) == 0; }
    constexpr bool is_single(TestSparseFlags value) noexcept { uint16_t n = static_cast<uint16_t>(value); return n && !(n & (n - 1)); }

    // TestSparseFlags Operator Overloads
    constexpr TestSparseFlags operator~(const TestSparseFlags a) noexcept { return static_cast<TestSparseFlags>(~static_cast<uint16_t>(a)); }
    constexpr TestSparseFlags operator|(const TestSparseFlags a, const TestSparseFlags b) noexcept { return static_cast<TestSparseFlags>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
    constexpr TestSparseFlags operator&(const TestSparseFlags a, const TestSparseFlags b) noexcept { return static_cast<TestSparseFlags>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
    constexpr TestSparseFlags operator^(const TestSparseFlags a, const TestSparseFlags b) noexcept { return static_cast<TestSparseFlags>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
    constexpr TestSparseFlags& operator|=(TestSparseFlags& a, const TestSparseFlags b) noexcept { return a = a | b; }
    constexpr TestSparseFlags& operator&=(TestSparseFlags& a, const TestSparseFlags b) noexcept { return a = a & b; }
    constexpr TestSparseFlags& operator^=(TestSparseFlags& a, const TestSparseFlags b) noexcept { return a = a ^ b; }

    // TestSingleFlag Definition
    enum class TestSingleFlag : uint16_t {
        C = 4,
    };

    namespace detail::TestSingleFlag {
        constexpr ::enums::TestSingleFlag flags_arr[1] =
        {
            ::enums::TestSingleFlag::C,
        };
    }

    template<>
    constexpr auto& flags<TestSingleFlag>() noexcept
    {
        return detail::TestSingleFlag::flags_arr;
    }

    constexpr void zero(TestSingleFlag& value) noexcept { value = static_cast<TestSingleFlag>(0); }
    constexpr bool test(TestSingleFlag value, TestSingleFlag flags) noexcept { return (static_cast<uint16_t>(flags) & static_cast<uint16_t>(value)) == static_cast<uint16_t>(flags); }
    constexpr void set(TestSingleFlag& value, TestSingleFlag flags) noexcept { value = static_cast<TestSingleFlag>(static_cast<uint16_t>(value) | static_cast<uint16_t>(flags)); }
    constexpr void unset(TestSingleFlag& value, TestSingleFlag flags) noexcept { value = static_cast<TestSingleFlag>(static_cast<uint16_t>(value) & (~static_cast<uint16_t>(flags))); }
    constexpr void toggle(TestSingleFlag& value, TestSingleFlag flags) noexcept { value = static_cast<TestSingleFlag>(static_cast<uint16_t>(value) ^ static_cast<uint16_t>(flags)); }
    constexpr bool is_all(TestSingleFlag value) noexcept { return static_cast<uint16_t>(value) >= 0x4; }
    constexpr bool is_any(TestSingleFlag value) noexcept { return static_cast<uint16_t>(value) > 0; }
    constexpr bool is_none(TestSingleFlag value) noexcept { return static_cast<uint16_t>(value) == 0; }
    constexpr bool is_single(TestSingleFlag value) noexcept { uint16_t n = static_cast<uint16_t>(value); return n && !(n & (n - 1)); }

    // TestSingleFlag Operator Overloads
    constexpr TestSingleFlag operator~(const TestSingleFlag a) noexcept { return static_cast<TestSingleFlag>(~static_cast<uint16_t>(a)); }
    constexpr TestSingleFlag operator|(const TestSingleFlag a, const TestSingleFlag b) noexcept { return static_cast<TestSingleFlag>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
    constexpr TestSingleFlag operator&(const TestSingleFlag a, const TestSingleFlag b) noexcept { return static_cast<TestSingleFlag>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
    constexpr TestSingleFlag operator^(const TestSingleFlag a, const TestSingleFlag b) noexcept { return static_cast<TestSingleFlag>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
    constexpr TestSingleFlag& operator|=(TestSingleFlag& a, const TestSingleFlag b) noexcept { return a = a | b; }
    constexpr TestSingleFlag& operator&=(TestSingleFlag& a, const TestSingleFlag b) noexcept { return a = a & b; }
    constexpr TestSingleFlag& operator^=(TestSingleFlag& a, const TestSingleFlag b) noexcept { return a = a ^ b; }

} // namespace enums

// Template Specializations Begin
template<> struct enumbra::detail::base_helper<enums::test_string_parse> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Unsigned64Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed64Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed32Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed16Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::Signed8Test> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::test_value> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::HexDiagonal> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest1> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest2> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest3> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::NegativeTest4> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Unsigned> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Signed> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Unsigned> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Signed> : enumbra::detail::type_info<true, true, false> { };
template<> struct enumbra::detail::base_helper<enums::test_flags> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::base_helper<enums::test_nodefault> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::base_helper<enums::TestSparseFlags> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::base_helper<enums::TestSingleFlag> : enumbra::detail::type_info<true, false, true> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_string_parse> : enumbra::detail::value_enum_info<int64_t, -1, 9223372036854775807, -1, int, 5, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Unsigned64Test> : enumbra::detail::value_enum_info<uint64_t, 0, 0xFFFFFFFFFFFFFFFF, 0, int, 4, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed64Test> : enumbra::detail::value_enum_info<int64_t, (-9223372036854775807 - 1), 9223372036854775807, (-9223372036854775807 - 1), int, 3, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed32Test> : enumbra::detail::value_enum_info<int32_t, (-2147483647 - 1), 2147483647, (-2147483647 - 1), int, 3, false, 32, 32> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed16Test> : enumbra::detail::value_enum_info<int16_t, (-32767 - 1), 32767, (-32767 - 1), int, 3, false, 16, 16> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed8Test> : enumbra::detail::value_enum_info<int8_t, (-127 - 1), 127, (-127 - 1), int, 3, false, 8, 8> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_value> : enumbra::detail::value_enum_info<int32_t, 0, 2, 0, int, 3, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::HexDiagonal> : enumbra::detail::value_enum_info<uint8_t, 0, 5, 0, int, 6, true, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest1> : enumbra::detail::value_enum_info<int8_t, -2, 1, -2, int, 4, true, 2, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest2> : enumbra::detail::value_enum_info<int8_t, -3, 0, -3, int, 4, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest3> : enumbra::detail::value_enum_info<int8_t, -3, 4, -3, int, 2, false, 4, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest4> : enumbra::detail::value_enum_info<int8_t, -4, 3, -4, int, 2, false, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Unsigned> : enumbra::detail::value_enum_info<uint8_t, 0, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Signed> : enumbra::detail::value_enum_info<int8_t, 0, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Unsigned> : enumbra::detail::value_enum_info<uint8_t, 4, 4, 4, int, 1, true, 3, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Signed> : enumbra::detail::value_enum_info<int8_t, 4, 4, 4, int, 1, true, 4, 0> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_flags> : enumbra::detail::flags_enum_info<uint32_t, 0, 3, 0, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_nodefault> : enumbra::detail::flags_enum_info<uint16_t, 0, 3, 0, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSparseFlags> : enumbra::detail::flags_enum_info<uint16_t, 0, 21, 0, int, 3, false, 5, 5> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSingleFlag> : enumbra::detail::flags_enum_info<uint16_t, 0, 4, 0, int, 1, true, 3, 3> { };
// Template Specializations End
