// THIS CODE WAS GENERATED BY A TOOL (haha)
// Direct your feedback and monetary donations to: https://github.com/Scaless/enumbra
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated. But do what you want, I'm a tool not a cop.
// Generated by enumbra v0.0.5 on Sat Jan  1 21:11:07 2022

// Hey! You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should edit your enumbra_config.toml file!

#pragma once

#include <array>
#include <cstdint>

#if !defined(ENUMBRA_REQUIRED_MACROS_VERSION)
#define ENUMBRA_REQUIRED_MACROS_VERSION 2

// Find out what language version we're using
#if (_MSVC_LANG >= 202002L) || (__cplusplus >= 202002L)
#define ENUMBRA_CPP_VERSION 20
#elif (_MSVC_LANG >= 201703L) || (__cplusplus >= 201703L)
#define ENUMBRA_CPP_VERSION 17
#elif (_MSVC_LANG >= 201402L) || (__cplusplus >= 201402L)
#define ENUMBRA_CPP_VERSION 14
#elif (_MSVC_LANG >= 201103L) || (__cplusplus >= 201103L)
#define ENUMBRA_CPP_VERSION 11
#else
#error enumbra generated headers require a C++11 or higher compiler.
#endif

// Non-const constexpr functions were added in C++14
#if __cpp_constexpr >= 201304L
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC constexpr
#else
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC inline
#endif

#else // check existing version supported
#if (ENUMBRA_REQUIRED_MACROS_VERSION + 0) == 0
#error ENUMBRA_REQUIRED_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_REQUIRED_MACROS_VERSION

#if !defined(ENUMBRA_OPTIONAL_MACROS_VERSION)
#define ENUMBRA_OPTIONAL_MACROS_VERSION 2

// Bit field storage helper
#define ENUMBRA_PACK(Enum, Name) Enum::Value Name : Enum::bits_required_storage();

#if ENUMBRA_CPP_VERSION >= 20
// Bit field storage helper with type-checked member initialization
#define ENUMBRA_PACK_INIT(Enum, Name, InitValue) Enum::Value Name : Enum::bits_required_storage() { InitValue }; \
    static_assert(is_enumbra_type(InitValue), "InitValue passed to ENUMBRA_PACK_INIT is not a valid enumbra type.");
// Bit field storage helper with default value initialization
#define ENUMBRA_PACK_INIT_DEFAULT(Enum, Name) Enum::Value Name : Enum::bits_required_storage() { Enum() };
#endif

#else // check existing version supported
#if (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) == 0
#error ENUMBRA_OPTIONAL_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_OPTIONAL_MACROS_VERSION

namespace enums {

// test_value Definition
struct test_value {
    using UnderlyingType = int32_t;
    enum class Value : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    constexpr test_value() : value_(Value(0)) { }
    constexpr test_value(Value v) : value_(v) { }

    constexpr static std::array<Value, 3> Values = {
        Value::A,
        Value::B,
        Value::C,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int32_t to_underlying() const { return static_cast<int32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = test_value(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int32_t min() { return 0; }
    static constexpr int32_t max() { return 2; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_value from_underlying_unsafe(int32_t v) { return test_value(static_cast<Value>(v)); }
    static constexpr int32_t bits_required_storage() { return 3; }
    static constexpr int32_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(test_value v) { return (0 <= static_cast<int32_t>(v.value_)) && (static_cast<int32_t>(v.value_) <= 2); }
    static constexpr bool is_valid(int32_t v) { return (0 <= v) && (v <= 2); }

private:
    Value value_;
};

// HexDiagonal Definition
struct HexDiagonal {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    constexpr HexDiagonal() : value_(Value(0)) { }
    constexpr HexDiagonal(Value v) : value_(v) { }

    constexpr static std::array<Value, 6> Values = {
        Value::NORTH,
        Value::NORTH_EAST,
        Value::SOUTH_EAST,
        Value::SOUTH,
        Value::SOUTH_WEST,
        Value::NORTH_WEST,
    };

    constexpr static Value NORTH = Value::NORTH;
    constexpr static Value NORTH_EAST = Value::NORTH_EAST;
    constexpr static Value SOUTH_EAST = Value::SOUTH_EAST;
    constexpr static Value SOUTH = Value::SOUTH;
    constexpr static Value SOUTH_WEST = Value::SOUTH_WEST;
    constexpr static Value NORTH_WEST = Value::NORTH_WEST;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = HexDiagonal(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr uint8_t min() { return 0; }
    static constexpr uint8_t max() { return 5; }
    static constexpr int count() { return 6; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr HexDiagonal from_underlying_unsafe(uint8_t v) { return HexDiagonal(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 3; }
    static constexpr uint8_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(HexDiagonal v) { return static_cast<uint8_t>(v.value_) <= 5; }
    static constexpr bool is_valid(uint8_t v) { return v <= 5; }

private:
    Value value_;
};

// NegativeTest1 Definition
struct NegativeTest1 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -2,
        B = -1,
        C = 0,
        D = 1,
    };

    constexpr NegativeTest1() : value_(Value(-2)) { }
    constexpr NegativeTest1(Value v) : value_(v) { }

    constexpr static std::array<Value, 4> Values = {
        Value::A,
        Value::B,
        Value::C,
        Value::D,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;
    constexpr static Value D = Value::D;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = NegativeTest1(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int8_t min() { return -2; }
    static constexpr int8_t max() { return 1; }
    static constexpr int count() { return 4; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr NegativeTest1 from_underlying_unsafe(int8_t v) { return NegativeTest1(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 2; }
    static constexpr int8_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(NegativeTest1 v) { return (-2 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 1); }
    static constexpr bool is_valid(int8_t v) { return (-2 <= v) && (v <= 1); }

private:
    Value value_;
};

// NegativeTest2 Definition
struct NegativeTest2 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -3,
        B = -2,
        C = -1,
        D = 0,
    };

    constexpr NegativeTest2() : value_(Value(-3)) { }
    constexpr NegativeTest2(Value v) : value_(v) { }

    constexpr static std::array<Value, 4> Values = {
        Value::A,
        Value::B,
        Value::C,
        Value::D,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;
    constexpr static Value D = Value::D;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = NegativeTest2(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int8_t min() { return -3; }
    static constexpr int8_t max() { return 0; }
    static constexpr int count() { return 4; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr NegativeTest2 from_underlying_unsafe(int8_t v) { return NegativeTest2(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 3; }
    static constexpr int8_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(NegativeTest2 v) { return (-3 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 0); }
    static constexpr bool is_valid(int8_t v) { return (-3 <= v) && (v <= 0); }

private:
    Value value_;
};

// NegativeTest3 Definition
struct NegativeTest3 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -3,
        B = 4,
    };

    constexpr NegativeTest3() : value_(Value(-3)) { }
    constexpr NegativeTest3(Value v) : value_(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::A,
        Value::B,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = NegativeTest3(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int8_t min() { return -3; }
    static constexpr int8_t max() { return 4; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr NegativeTest3 from_underlying_unsafe(int8_t v) { return NegativeTest3(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 4; }
    static constexpr int8_t bits_required_transmission() { return 2; }
    static inline bool is_valid(NegativeTest3 v) { return std::find(Values.begin(), Values.end(), v) != Values.end(); }
    static inline bool is_valid(int8_t v) { return std::find(Values.begin(), Values.end(), from_underlying_unsafe(v)) != Values.end(); }

private:
    Value value_;
};

// NegativeTest4 Definition
struct NegativeTest4 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -4,
        B = 3,
    };

    constexpr NegativeTest4() : value_(Value(-4)) { }
    constexpr NegativeTest4(Value v) : value_(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::A,
        Value::B,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = NegativeTest4(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int8_t min() { return -4; }
    static constexpr int8_t max() { return 3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr NegativeTest4 from_underlying_unsafe(int8_t v) { return NegativeTest4(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 3; }
    static constexpr int8_t bits_required_transmission() { return 2; }
    static inline bool is_valid(NegativeTest4 v) { return std::find(Values.begin(), Values.end(), v) != Values.end(); }
    static inline bool is_valid(int8_t v) { return std::find(Values.begin(), Values.end(), from_underlying_unsafe(v)) != Values.end(); }

private:
    Value value_;
};

// EmptyTest1Unsigned Definition
struct EmptyTest1Unsigned {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        A = 0,
    };

    constexpr EmptyTest1Unsigned() : value_(Value(0)) { }
    constexpr EmptyTest1Unsigned(Value v) : value_(v) { }

    constexpr static std::array<Value, 1> Values = {
        Value::A,
    };

    constexpr static Value A = Value::A;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = EmptyTest1Unsigned(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr uint8_t min() { return 0; }
    static constexpr uint8_t max() { return 0; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr EmptyTest1Unsigned from_underlying_unsafe(uint8_t v) { return EmptyTest1Unsigned(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 1; }
    static constexpr uint8_t bits_required_transmission() { return 0; }
    static constexpr bool is_valid(EmptyTest1Unsigned v) { return static_cast<uint8_t>(v.value_) <= 0; }
    static constexpr bool is_valid(uint8_t v) { return v <= 0; }

private:
    Value value_;
};

// EmptyTest1Signed Definition
struct EmptyTest1Signed {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = 0,
    };

    constexpr EmptyTest1Signed() : value_(Value(0)) { }
    constexpr EmptyTest1Signed(Value v) : value_(v) { }

    constexpr static std::array<Value, 1> Values = {
        Value::A,
    };

    constexpr static Value A = Value::A;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = EmptyTest1Signed(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int8_t min() { return 0; }
    static constexpr int8_t max() { return 0; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr EmptyTest1Signed from_underlying_unsafe(int8_t v) { return EmptyTest1Signed(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 1; }
    static constexpr int8_t bits_required_transmission() { return 0; }
    static constexpr bool is_valid(EmptyTest1Signed v) { return (0 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 0); }
    static constexpr bool is_valid(int8_t v) { return (0 <= v) && (v <= 0); }

private:
    Value value_;
};

// SingleTest1Unsigned Definition
struct SingleTest1Unsigned {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        A = 4,
    };

    constexpr SingleTest1Unsigned() : value_(Value(4)) { }
    constexpr SingleTest1Unsigned(Value v) : value_(v) { }

    constexpr static std::array<Value, 1> Values = {
        Value::A,
    };

    constexpr static Value A = Value::A;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = SingleTest1Unsigned(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr uint8_t min() { return 4; }
    static constexpr uint8_t max() { return 4; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr SingleTest1Unsigned from_underlying_unsafe(uint8_t v) { return SingleTest1Unsigned(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 3; }
    static constexpr uint8_t bits_required_transmission() { return 0; }
    static constexpr bool is_valid(SingleTest1Unsigned v) { return (4 <= static_cast<uint8_t>(v.value_)) && (static_cast<uint8_t>(v.value_) <= 4); }
    static constexpr bool is_valid(uint8_t v) { return (4 <= v) && (v <= 4); }

private:
    Value value_;
};

// SingleTest1Signed Definition
struct SingleTest1Signed {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = 4,
    };

    constexpr SingleTest1Signed() : value_(Value(4)) { }
    constexpr SingleTest1Signed(Value v) : value_(v) { }

    constexpr static std::array<Value, 1> Values = {
        Value::A,
    };

    constexpr static Value A = Value::A;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = SingleTest1Signed(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int8_t min() { return 4; }
    static constexpr int8_t max() { return 4; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr SingleTest1Signed from_underlying_unsafe(int8_t v) { return SingleTest1Signed(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 4; }
    static constexpr int8_t bits_required_transmission() { return 0; }
    static constexpr bool is_valid(SingleTest1Signed v) { return (4 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 4); }
    static constexpr bool is_valid(int8_t v) { return (4 <= v) && (v <= 4); }

private:
    Value value_;
};

// test_flags Definition
struct test_flags {
    using UnderlyingType = uint32_t;
    enum class Value : uint32_t {
        B = 1,
        C = 2,
    };

    constexpr test_flags() : value_(Value(0)) { }
    constexpr test_flags(Value v) : value_(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::B,
        Value::C,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint32_t to_underlying() const { return static_cast<uint32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_flags(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint32_t>(value_) & static_cast<uint32_t>(v)) == static_cast<uint32_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint32_t>(value_) & (~static_cast<uint32_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint32_t>(value_) ^ static_cast<uint32_t>(v)); }
    constexpr bool all() const { return static_cast<uint32_t>(value_) >= 0x3; }
    constexpr bool any() const { return static_cast<uint32_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint32_t>(value_) == 0; }
    constexpr bool single() const { uint32_t n = static_cast<uint32_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint32_t min() { return 0; }
    static constexpr uint32_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_flags from_underlying_unsafe(uint32_t v) { return test_flags(static_cast<Value>(v)); }
    static constexpr uint32_t bits_required_storage() { return 2; }
    static constexpr uint32_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_flags v) { return static_cast<uint32_t>(v.value_) <= 3; }
    static constexpr bool is_valid(uint32_t v) { return v <= 3; }

private:
    Value value_;
};

// test_flags Operator Overloads
constexpr test_flags::Value operator~(const test_flags::Value a) { return static_cast<test_flags::Value>(~static_cast<uint32_t>(a)); }
constexpr test_flags::Value operator|(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator&(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator^(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
constexpr test_flags operator~(const test_flags a) { return ~a.value(); }
constexpr test_flags operator|(const test_flags a, const test_flags b) { return a.value() | b.value(); }
constexpr test_flags operator&(const test_flags a, const test_flags b) { return a.value() & b.value(); }
constexpr test_flags operator^(const test_flags a, const test_flags b) { return a.value() ^ b.value(); }
constexpr test_flags operator|(const test_flags a, const test_flags::Value b) { return a.value() | b; }
constexpr test_flags operator&(const test_flags a, const test_flags::Value b) { return a.value() & b; }
constexpr test_flags operator^(const test_flags a, const test_flags::Value b) { return a.value() ^ b; }
constexpr test_flags operator|(const test_flags::Value a, const test_flags b) { return a | b.value(); }
constexpr test_flags operator&(const test_flags::Value a, const test_flags b) { return a & b.value(); }
constexpr test_flags operator^(const test_flags::Value a, const test_flags b) { return a ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator|=(test_flags& a, const test_flags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator&=(test_flags& a, const test_flags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator^=(test_flags& a, const test_flags b) { a = a ^ b; return a; }

// test_nodefault Definition
struct test_nodefault {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        B = 1,
        C = 2,
    };

    constexpr test_nodefault() : value_(Value(0)) { }
    constexpr test_nodefault(Value v) : value_(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::B,
        Value::C,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_nodefault(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 0x3; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }
    constexpr bool single() const { uint16_t n = static_cast<uint32_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_nodefault from_underlying_unsafe(uint16_t v) { return test_nodefault(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 2; }
    static constexpr uint16_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_nodefault v) { return static_cast<uint16_t>(v.value_) <= 3; }
    static constexpr bool is_valid(uint16_t v) { return v <= 3; }

private:
    Value value_;
};

// test_nodefault Operator Overloads
constexpr test_nodefault::Value operator~(const test_nodefault::Value a) { return static_cast<test_nodefault::Value>(~static_cast<uint16_t>(a)); }
constexpr test_nodefault::Value operator|(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator&(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator^(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr test_nodefault operator~(const test_nodefault a) { return ~a.value(); }
constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b) { return a.value() | b.value(); }
constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b) { return a.value() & b.value(); }
constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b) { return a.value() ^ b.value(); }
constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault::Value b) { return a.value() | b; }
constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault::Value b) { return a.value() & b; }
constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault::Value b) { return a.value() ^ b; }
constexpr test_nodefault operator|(const test_nodefault::Value a, const test_nodefault b) { return a | b.value(); }
constexpr test_nodefault operator&(const test_nodefault::Value a, const test_nodefault b) { return a & b.value(); }
constexpr test_nodefault operator^(const test_nodefault::Value a, const test_nodefault b) { return a ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator|=(test_nodefault& a, const test_nodefault b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator&=(test_nodefault& a, const test_nodefault b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator^=(test_nodefault& a, const test_nodefault b) { a = a ^ b; return a; }

// TestSparseFlags Definition
struct TestSparseFlags {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        B = 1,
        C = 4,
        D = 16,
    };

    constexpr TestSparseFlags() : value_(Value(0)) { }
    constexpr TestSparseFlags(Value v) : value_(v) { }

    constexpr static std::array<Value, 3> Values = {
        Value::B,
        Value::C,
        Value::D,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;
    constexpr static Value D = Value::D;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = TestSparseFlags(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 0x15; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }
    constexpr bool single() const { uint16_t n = static_cast<uint32_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x15; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr TestSparseFlags from_underlying_unsafe(uint16_t v) { return TestSparseFlags(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 5; }
    static constexpr uint16_t bits_required_transmission() { return 5; }
    static inline bool is_valid(TestSparseFlags v) { return std::find(Values.begin(), Values.end(), v) != Values.end(); }
    static inline bool is_valid(uint16_t v) { return std::find(Values.begin(), Values.end(), from_underlying_unsafe(v)) != Values.end(); }

private:
    Value value_;
};

// TestSparseFlags Operator Overloads
constexpr TestSparseFlags::Value operator~(const TestSparseFlags::Value a) { return static_cast<TestSparseFlags::Value>(~static_cast<uint16_t>(a)); }
constexpr TestSparseFlags::Value operator|(const TestSparseFlags::Value a, const TestSparseFlags::Value b) { return static_cast<TestSparseFlags::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr TestSparseFlags::Value operator&(const TestSparseFlags::Value a, const TestSparseFlags::Value b) { return static_cast<TestSparseFlags::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr TestSparseFlags::Value operator^(const TestSparseFlags::Value a, const TestSparseFlags::Value b) { return static_cast<TestSparseFlags::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr TestSparseFlags operator~(const TestSparseFlags a) { return ~a.value(); }
constexpr TestSparseFlags operator|(const TestSparseFlags a, const TestSparseFlags b) { return a.value() | b.value(); }
constexpr TestSparseFlags operator&(const TestSparseFlags a, const TestSparseFlags b) { return a.value() & b.value(); }
constexpr TestSparseFlags operator^(const TestSparseFlags a, const TestSparseFlags b) { return a.value() ^ b.value(); }
constexpr TestSparseFlags operator|(const TestSparseFlags a, const TestSparseFlags::Value b) { return a.value() | b; }
constexpr TestSparseFlags operator&(const TestSparseFlags a, const TestSparseFlags::Value b) { return a.value() & b; }
constexpr TestSparseFlags operator^(const TestSparseFlags a, const TestSparseFlags::Value b) { return a.value() ^ b; }
constexpr TestSparseFlags operator|(const TestSparseFlags::Value a, const TestSparseFlags b) { return a | b.value(); }
constexpr TestSparseFlags operator&(const TestSparseFlags::Value a, const TestSparseFlags b) { return a & b.value(); }
constexpr TestSparseFlags operator^(const TestSparseFlags::Value a, const TestSparseFlags b) { return a ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator|=(TestSparseFlags& a, const TestSparseFlags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator&=(TestSparseFlags& a, const TestSparseFlags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator^=(TestSparseFlags& a, const TestSparseFlags b) { a = a ^ b; return a; }

// TestSingleFlag Definition
struct TestSingleFlag {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        C = 4,
    };

    constexpr TestSingleFlag() : value_(Value(0)) { }
    constexpr TestSingleFlag(Value v) : value_(v) { }

    constexpr static std::array<Value, 1> Values = {
        Value::C,
    };

    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = TestSingleFlag(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 0x4; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }
    constexpr bool single() const { uint16_t n = static_cast<uint32_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x4; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr TestSingleFlag from_underlying_unsafe(uint16_t v) { return TestSingleFlag(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 3; }
    static constexpr uint16_t bits_required_transmission() { return 3; }
    static constexpr bool is_valid(TestSingleFlag v) { return static_cast<uint16_t>(v.value_) <= 4; }
    static constexpr bool is_valid(uint16_t v) { return v <= 4; }

private:
    Value value_;
};

// TestSingleFlag Operator Overloads
constexpr TestSingleFlag::Value operator~(const TestSingleFlag::Value a) { return static_cast<TestSingleFlag::Value>(~static_cast<uint16_t>(a)); }
constexpr TestSingleFlag::Value operator|(const TestSingleFlag::Value a, const TestSingleFlag::Value b) { return static_cast<TestSingleFlag::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr TestSingleFlag::Value operator&(const TestSingleFlag::Value a, const TestSingleFlag::Value b) { return static_cast<TestSingleFlag::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr TestSingleFlag::Value operator^(const TestSingleFlag::Value a, const TestSingleFlag::Value b) { return static_cast<TestSingleFlag::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr TestSingleFlag operator~(const TestSingleFlag a) { return ~a.value(); }
constexpr TestSingleFlag operator|(const TestSingleFlag a, const TestSingleFlag b) { return a.value() | b.value(); }
constexpr TestSingleFlag operator&(const TestSingleFlag a, const TestSingleFlag b) { return a.value() & b.value(); }
constexpr TestSingleFlag operator^(const TestSingleFlag a, const TestSingleFlag b) { return a.value() ^ b.value(); }
constexpr TestSingleFlag operator|(const TestSingleFlag a, const TestSingleFlag::Value b) { return a.value() | b; }
constexpr TestSingleFlag operator&(const TestSingleFlag a, const TestSingleFlag::Value b) { return a.value() & b; }
constexpr TestSingleFlag operator^(const TestSingleFlag a, const TestSingleFlag::Value b) { return a.value() ^ b; }
constexpr TestSingleFlag operator|(const TestSingleFlag::Value a, const TestSingleFlag b) { return a | b.value(); }
constexpr TestSingleFlag operator&(const TestSingleFlag::Value a, const TestSingleFlag b) { return a & b.value(); }
constexpr TestSingleFlag operator^(const TestSingleFlag::Value a, const TestSingleFlag b) { return a ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator|=(TestSingleFlag& a, const TestSingleFlag b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator&=(TestSingleFlag& a, const TestSingleFlag b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator^=(TestSingleFlag& a, const TestSingleFlag b) { a = a ^ b; return a; }

} // namespace enums

#if !defined(ENUMBRA_BASE_TEMPLATES_VERSION)
#define ENUMBRA_BASE_TEMPLATES_VERSION 2
namespace enumbra {
    namespace detail {
        // Default templates for non-enumbra types
        template<class T>
        struct enumbra_base_helper { 
            static constexpr bool enumbra_type = false;
            static constexpr bool enumbra_enum_class = false;
            static constexpr bool enumbra_value_enum = false;
            static constexpr bool enumbra_flags_enum = false;
            using base_type = T; 
        };
    } // end namespace enumbra::detail
    template<class T> using enumbra_base_t = typename detail::enumbra_base_helper<T>::base_type;
    template<class T> constexpr bool is_enumbra_type() { return detail::enumbra_base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_type(T v) { return detail::enumbra_base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_struct() { return is_enumbra_type<T>() && !detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_struct(T v) { return is_enumbra_type<T>() && !detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum(T v) { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_value_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_value_enum(T v) { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_flags_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum(T v) { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_flags_enum; }
} // end namespace enumbra
#else // check existing version supported
#if (ENUMBRA_BASE_TEMPLATES_VERSION + 0) == 0
#error ENUMBRA_BASE_TEMPLATES_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using same version of enumbra.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using same version of enumbra.
#endif // check existing version supported
#endif // ENUMBRA_BASE_TEMPLATES_VERSION

// enums::test_value Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_value::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::test_value;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::test_value;
};
// enums::HexDiagonal Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::HexDiagonal::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::HexDiagonal;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::HexDiagonal> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::HexDiagonal;
};
// enums::NegativeTest1 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest1::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest1;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest1> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest1;
};
// enums::NegativeTest2 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest2::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest2;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest2> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest2;
};
// enums::NegativeTest3 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest3::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest3;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest3> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest3;
};
// enums::NegativeTest4 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest4::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest4;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest4> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest4;
};
// enums::EmptyTest1Unsigned Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Unsigned::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Unsigned;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Unsigned> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Unsigned;
};
// enums::EmptyTest1Signed Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Signed::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Signed;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Signed> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Signed;
};
// enums::SingleTest1Unsigned Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Unsigned::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Unsigned;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Unsigned> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Unsigned;
};
// enums::SingleTest1Signed Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Signed::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Signed;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Signed> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Signed;
};
// enums::test_flags Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_flags::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_flags;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_flags> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_flags;
};
// enums::test_nodefault Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_nodefault::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_nodefault;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_nodefault> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_nodefault;
};
// enums::TestSparseFlags Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSparseFlags::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSparseFlags;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSparseFlags> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSparseFlags;
};
// enums::TestSingleFlag Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSingleFlag::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSingleFlag;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSingleFlag> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSingleFlag;
};
