// THIS CODE WAS GENERATED BY A TOOL (haha)
// Direct your feedback and monetary donations to: https://github.com/Scaless/enumbra
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated. But do what you want, I'm a tool not a cop.
// Generated by enumbra v0.0.4 on Sat Jan  1 15:56:47 2022

// Hey! You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should edit your enumbra_config.toml file!

#pragma once

#include <array>
#include <cstdint>

#if !defined(ENUMBRA_OPTIONAL_MACROS_VERSION)
#define ENUMBRA_OPTIONAL_MACROS_VERSION 2
#define ENUMBRA_PACK(Enum, Name) Enum::Value Name : Enum::bits_required_storage();
#else // check existing version supported
#if (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) == 0
#error ENUMBRA_OPTIONAL_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_OPTIONAL_MACROS_VERSION

#if !defined(ENUMBRA_REQUIRED_MACROS_VERSION)
#define ENUMBRA_REQUIRED_MACROS_VERSION 2
#if !defined(__cpp_constexpr)
#error enumbra requires a C++11 or higher compiler.
#elif __cpp_constexpr >= 201304L
// Non-const constexpr functions were added in C++14
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC constexpr
#else
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC inline
#endif
#else // check existing version supported
#if (ENUMBRA_REQUIRED_MACROS_VERSION + 0) == 0
#error ENUMBRA_REQUIRED_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_REQUIRED_MACROS_VERSION

namespace enums {

// test_value Definition
struct test_value {
    using UnderlyingType = int32_t;
    enum class Value : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    constexpr test_value() : value_(Value(0)) { }
    constexpr test_value(Value v) : value_(v) { }

    constexpr static std::array<Value, 3> Values = {
        Value::A,
        Value::B,
        Value::C,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int32_t to_underlying() const { return static_cast<int32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = test_value(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr int32_t min() { return 0; }
    static constexpr int32_t max() { return 2; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_value from_underlying_unsafe(int32_t v) { return test_value(static_cast<Value>(v)); }
    static constexpr int32_t bits_required_storage() { return 2; }
    static constexpr int32_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_value v) { return (0 <= static_cast<int32_t>(v.value_)) && (static_cast<int32_t>(v.value_) <= 2); }
    static constexpr bool is_valid(int32_t v) { return (0 <= v) && (v <= 2); }

private:
    Value value_;
};

// HexDiagonal Definition
struct HexDiagonal {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    constexpr HexDiagonal() : value_(Value(0)) { }
    constexpr HexDiagonal(Value v) : value_(v) { }

    constexpr static std::array<Value, 6> Values = {
        Value::NORTH,
        Value::NORTH_EAST,
        Value::SOUTH_EAST,
        Value::SOUTH,
        Value::SOUTH_WEST,
        Value::NORTH_WEST,
    };

    constexpr static Value NORTH = Value::NORTH;
    constexpr static Value NORTH_EAST = Value::NORTH_EAST;
    constexpr static Value SOUTH_EAST = Value::SOUTH_EAST;
    constexpr static Value SOUTH = Value::SOUTH;
    constexpr static Value SOUTH_WEST = Value::SOUTH_WEST;
    constexpr static Value NORTH_WEST = Value::NORTH_WEST;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { value_ = HexDiagonal(); }

    static constexpr bool is_enumbra_value_enum() { return true; }
    static constexpr bool is_enumbra_flags_enum() { return false; }
    static constexpr uint8_t min() { return 0; }
    static constexpr uint8_t max() { return 5; }
    static constexpr int count() { return 6; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr HexDiagonal from_underlying_unsafe(uint8_t v) { return HexDiagonal(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 3; }
    static constexpr uint8_t bits_required_transmission() { return 3; }
    static constexpr bool is_valid(HexDiagonal v) { return static_cast<uint8_t>(v.value_) <= 5; }
    static constexpr bool is_valid(uint8_t v) { return v <= 5; }

private:
    Value value_;
};

// test_flags Definition
struct test_flags {
    using UnderlyingType = uint32_t;
    enum class Value : uint32_t {
        B = 1,
        C = 2,
    };

    constexpr test_flags() : value_(Value(0)) { }
    constexpr test_flags(Value v) : value_(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::B,
        Value::C,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint32_t to_underlying() const { return static_cast<uint32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_flags(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint32_t>(value_) & static_cast<uint32_t>(v)) == static_cast<uint32_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint32_t>(value_) & (~static_cast<uint32_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint32_t>(value_) ^ static_cast<uint32_t>(v)); }
    constexpr bool all() const { return static_cast<uint32_t>(value_) >= 3; }
    constexpr bool any() const { return static_cast<uint32_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint32_t>(value_) == 0; }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint32_t min() { return 0; }
    static constexpr uint32_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_flags from_underlying_unsafe(uint32_t v) { return test_flags(static_cast<Value>(v)); }
    static constexpr uint32_t bits_required_storage() { return 2; }
    static constexpr uint32_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_flags v) { return static_cast<uint32_t>(v.value_) <= 3; }
    static constexpr bool is_valid(uint32_t v) { return v <= 3; }

private:
    Value value_;
};

// test_flags Operator Overloads
constexpr test_flags::Value operator~(const test_flags::Value a) { return static_cast<test_flags::Value>(~static_cast<uint32_t>(a)); }
constexpr test_flags::Value operator|(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator&(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator^(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
constexpr test_flags operator~(const test_flags a) { return ~a.value(); }
constexpr test_flags operator|(const test_flags a, const test_flags b) { return a.value() | b.value(); }
constexpr test_flags operator&(const test_flags a, const test_flags b) { return a.value() & b.value(); }
constexpr test_flags operator^(const test_flags a, const test_flags b) { return a.value() ^ b.value(); }
constexpr test_flags operator|(const test_flags a, const test_flags::Value b) { return a.value() | b; }
constexpr test_flags operator&(const test_flags a, const test_flags::Value b) { return a.value() & b; }
constexpr test_flags operator^(const test_flags a, const test_flags::Value b) { return a.value() ^ b; }
constexpr test_flags operator|(const test_flags::Value a, const test_flags b) { return a | b.value(); }
constexpr test_flags operator&(const test_flags::Value a, const test_flags b) { return a & b.value(); }
constexpr test_flags operator^(const test_flags::Value a, const test_flags b) { return a ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator|=(test_flags& a, const test_flags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator&=(test_flags& a, const test_flags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator^=(test_flags& a, const test_flags b) { a = a ^ b; return a; }

// test_nodefault Definition
struct test_nodefault {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        B = 1,
        C = 2,
    };

    constexpr test_nodefault() : value_(Value(0)) { }
    constexpr test_nodefault(Value v) : value_(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::B,
        Value::C,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_nodefault(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 3; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_nodefault from_underlying_unsafe(uint16_t v) { return test_nodefault(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 2; }
    static constexpr uint16_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_nodefault v) { return static_cast<uint16_t>(v.value_) <= 3; }
    static constexpr bool is_valid(uint16_t v) { return v <= 3; }

private:
    Value value_;
};

// test_nodefault Operator Overloads
constexpr test_nodefault::Value operator~(const test_nodefault::Value a) { return static_cast<test_nodefault::Value>(~static_cast<uint16_t>(a)); }
constexpr test_nodefault::Value operator|(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator&(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator^(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr test_nodefault operator~(const test_nodefault a) { return ~a.value(); }
constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b) { return a.value() | b.value(); }
constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b) { return a.value() & b.value(); }
constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b) { return a.value() ^ b.value(); }
constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault::Value b) { return a.value() | b; }
constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault::Value b) { return a.value() & b; }
constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault::Value b) { return a.value() ^ b; }
constexpr test_nodefault operator|(const test_nodefault::Value a, const test_nodefault b) { return a | b.value(); }
constexpr test_nodefault operator&(const test_nodefault::Value a, const test_nodefault b) { return a & b.value(); }
constexpr test_nodefault operator^(const test_nodefault::Value a, const test_nodefault b) { return a ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator|=(test_nodefault& a, const test_nodefault b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator&=(test_nodefault& a, const test_nodefault b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator^=(test_nodefault& a, const test_nodefault b) { a = a ^ b; return a; }

} // namespace enums

#if !defined(ENUMBRA_BASE_TEMPLATES_VERSION)
#define ENUMBRA_BASE_TEMPLATES_VERSION 2
namespace enumbra {
    namespace detail {
        // Default templates for non-enumbra types
        template<class T>
        struct enumbra_base_helper { 
            static constexpr bool enumbra_type = false;
            static constexpr bool enumbra_enum_class = false;
            static constexpr bool enumbra_value_enum = false;
            static constexpr bool enumbra_flags_enum = false;
            using base_type = T; 
        };
    } // end namespace enumbra::detail
    template<class T> using enumbra_base_t = typename detail::enumbra_base_helper<T>::base_type;
    template<class T> constexpr bool is_enumbra_type() { return detail::enumbra_base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_struct() { return is_enumbra_type<T>() && !detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_value_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_flags_enum; }
} // end namespace enumbra
#else // check existing version supported
#if (ENUMBRA_BASE_TEMPLATES_VERSION + 0) == 0
#error ENUMBRA_BASE_TEMPLATES_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using same version of enumbra.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using same version of enumbra.
#endif // check existing version supported
#endif // ENUMBRA_BASE_TEMPLATES_VERSION

// enums::test_value Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_value::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::test_value;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::test_value;
};
// enums::HexDiagonal Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::HexDiagonal::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::HexDiagonal;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::HexDiagonal> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::HexDiagonal;
};
// enums::test_flags Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_flags::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_flags;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_flags> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_flags;
};
// enums::test_nodefault Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_nodefault::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_nodefault;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_nodefault> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_nodefault;
};
