// THIS FILE WAS GENERATED BY A TOOL (haha)
// Direct your feedback and monetary donations to: https://github.com/Scaless/enumbra
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated.
// Generated by enumbra v0.0.8

// You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should put it in your enumbra_config.json file!

#pragma once

#include <array>
#include <cstdint>

#if !defined(ENUMBRA_REQUIRED_MACROS_VERSION)
#define ENUMBRA_REQUIRED_MACROS_VERSION 2

// Find out what language version we're using
#if (_MSVC_LANG >= 202002L) || (__cplusplus >= 202002L)
#define ENUMBRA_CPP_VERSION 20
#elif (_MSVC_LANG >= 201703L) || (__cplusplus >= 201703L)
#define ENUMBRA_CPP_VERSION 17
#elif (_MSVC_LANG >= 201402L) || (__cplusplus >= 201402L)
#define ENUMBRA_CPP_VERSION 14
#elif (_MSVC_LANG >= 201103L) || (__cplusplus >= 201103L)
#define ENUMBRA_CPP_VERSION 11
#else
#error enumbra generated headers require a C++11 or higher compiler.
#endif

// Non-const constexpr functions were added in C++14
#if __cpp_constexpr >= 201304L
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC constexpr
#else
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC inline
#endif


#else // check existing version supported
#if (ENUMBRA_REQUIRED_MACROS_VERSION + 0) == 0
#error ENUMBRA_REQUIRED_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_REQUIRED_MACROS_VERSION

#if !defined(ENUMBRA_OPTIONAL_MACROS_VERSION)
#define ENUMBRA_OPTIONAL_MACROS_VERSION 2

// Bit field storage helper
#define ENUMBRA_PACK_UNINITIALIZED(Enum, Name) Enum::Value Name : Enum::bits_required_storage();
#define ENUMBRA_INIT(Name, InitValue) Name(enumbra::enumbra_base_t<decltype(Name)>(InitValue).value())
#define ENUMBRA_INIT_DEFAULT(Name) Name(enumbra::enumbra_base_t<decltype(Name)>::default_value())

#if ENUMBRA_CPP_VERSION >= 20
// Bit field storage helper with type-checked member initialization
#define ENUMBRA_PACK_INIT(Enum, Name, InitValue) Enum::Value Name : Enum::bits_required_storage() { enumbra::enumbra_base_t<Enum>(InitValue).value() };
// Bit field storage helper with default value initialization
#define ENUMBRA_PACK_INIT_DEFAULT(Enum, Name) Enum::Value Name : Enum::bits_required_storage() { Enum().value() };
#endif

#else // check existing version supported
#if (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) == 0
#error ENUMBRA_OPTIONAL_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_OPTIONAL_MACROS_VERSION

#if !defined(ENUMBRA_BASE_TEMPLATES_VERSION)
#define ENUMBRA_BASE_TEMPLATES_VERSION 2
namespace enumbra {
    namespace detail {
        // Default templates for non-enumbra types
        template<class T>
        struct enumbra_base_helper { 
            static constexpr bool enumbra_type = false;
            static constexpr bool enumbra_enum_class = false;
            static constexpr bool enumbra_value_enum = false;
            static constexpr bool enumbra_flags_enum = false;
            using base_type = T; 
        };
        template<class T> constexpr bool streq(T* a, T* b) { return *a == *b && (*a == '\0' || streq(a + 1, b + 1)); }
    } // end namespace enumbra::detail
    template<class T> using enumbra_base_t = typename detail::enumbra_base_helper<T>::base_type;
    template<class T> constexpr bool is_enumbra_type() { return detail::enumbra_base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_type(T v) { return detail::enumbra_base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_struct() { return is_enumbra_type<T>() && !detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_struct(T v) { return is_enumbra_type<T>() && !detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum(T v) { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_value_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_value_enum(T v) { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum() { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_flags_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum(T v) { return is_enumbra_type<T>() && detail::enumbra_base_helper<T>::enumbra_flags_enum; }
} // end namespace enumbra
#else // check existing version supported
#if (ENUMBRA_BASE_TEMPLATES_VERSION + 0) == 0
#error ENUMBRA_BASE_TEMPLATES_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) < 2
#error An included header was generated using a newer version of enumbra. Regenerate your headers using same version of enumbra.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) > 2
#error An included header was generated using an older version of enumbra. Regenerate your headers using same version of enumbra.
#endif // check existing version supported
#endif // ENUMBRA_BASE_TEMPLATES_VERSION

namespace enums {

// Unsigned64Test Definition
struct Unsigned64Test {
    using UnderlyingType = uint64_t;
    enum class Value : uint64_t {
        MAX = 0xFFFFFFFFFFFFFFFF,
        MIN = 0,
        V_UINT16_MAX = 0xFFFF,
        V_UINT32_MAX = 0xFFFFFFFF,
    };

    constexpr Unsigned64Test() : value_(Value(0)) { }
    constexpr Unsigned64Test(Value v) : value_(v) { }

    constexpr static Value MAX = Value::MAX;
    constexpr static Value MIN = Value::MIN;
    constexpr static Value V_UINT16_MAX = Value::V_UINT16_MAX;
    constexpr static Value V_UINT32_MAX = Value::V_UINT32_MAX;

    constexpr static std::array<Value, 4> Values = {
        MAX, MIN, V_UINT16_MAX, V_UINT32_MAX, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint64_t to_underlying() const { return static_cast<uint64_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = Unsigned64Test(); }

    static constexpr Unsigned64Test::Value default_value() { return Value(0); }
    static constexpr uint64_t min() { return 0; }
    static constexpr uint64_t max() { return 0xFFFFFFFFFFFFFFFF; }
    static constexpr int count() { return 4; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr Unsigned64Test from_underlying_unsafe(uint64_t v) { return Unsigned64Test(static_cast<Value>(v)); }
    static constexpr uint64_t bits_required_storage() { return 64; }
    static constexpr uint64_t bits_required_transmission() { return 64; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(Unsigned64Test v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(uint64_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Unsigned64Test::Value v) {
        switch (v) {
            case MAX: return "MAX";
            case MIN: return "MIN";
            case V_UINT16_MAX: return "V_UINT16_MAX";
            case V_UINT32_MAX: return "V_UINT32_MAX";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 4> string_lookup_ = {
        std::make_pair(MAX, "MAX"),
        std::make_pair(MIN, "MIN"),
        std::make_pair(V_UINT16_MAX, "V_UINT16_MAX"),
        std::make_pair(V_UINT32_MAX, "V_UINT32_MAX"),
    };
};

// Signed64Test Definition
struct Signed64Test {
    using UnderlyingType = int64_t;
    enum class Value : int64_t {
        MIN = (-9223372036854775807 - 1),
        MAX = 9223372036854775807,
        NEG_ONE = -1,
    };

    constexpr Signed64Test() : value_(Value((-9223372036854775807 - 1))) { }
    constexpr Signed64Test(Value v) : value_(v) { }

    constexpr static Value MIN = Value::MIN;
    constexpr static Value MAX = Value::MAX;
    constexpr static Value NEG_ONE = Value::NEG_ONE;

    constexpr static std::array<Value, 3> Values = {
        MIN, MAX, NEG_ONE, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int64_t to_underlying() const { return static_cast<int64_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = Signed64Test(); }

    static constexpr Signed64Test::Value default_value() { return Value((-9223372036854775807 - 1)); }
    static constexpr int64_t min() { return (-9223372036854775807 - 1); }
    static constexpr int64_t max() { return 9223372036854775807; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr Signed64Test from_underlying_unsafe(int64_t v) { return Signed64Test(static_cast<Value>(v)); }
    static constexpr int64_t bits_required_storage() { return 64; }
    static constexpr int64_t bits_required_transmission() { return 64; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(Signed64Test v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(int64_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed64Test::Value v) {
        switch (v) {
            case MIN: return "MIN";
            case MAX: return "MAX";
            case NEG_ONE: return "NEG_ONE";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 3> string_lookup_ = {
        std::make_pair(MIN, "MIN"),
        std::make_pair(MAX, "MAX"),
        std::make_pair(NEG_ONE, "NEG_ONE"),
    };
};

// Signed32Test Definition
struct Signed32Test {
    using UnderlyingType = int32_t;
    enum class Value : int32_t {
        MIN = (-2147483647 - 1),
        MAX = 2147483647,
        NEG_ONE = -1,
    };

    constexpr Signed32Test() : value_(Value((-2147483647 - 1))) { }
    constexpr Signed32Test(Value v) : value_(v) { }

    constexpr static Value MIN = Value::MIN;
    constexpr static Value MAX = Value::MAX;
    constexpr static Value NEG_ONE = Value::NEG_ONE;

    constexpr static std::array<Value, 3> Values = {
        MIN, MAX, NEG_ONE, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int32_t to_underlying() const { return static_cast<int32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = Signed32Test(); }

    static constexpr Signed32Test::Value default_value() { return Value((-2147483647 - 1)); }
    static constexpr int32_t min() { return (-2147483647 - 1); }
    static constexpr int32_t max() { return 2147483647; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr Signed32Test from_underlying_unsafe(int32_t v) { return Signed32Test(static_cast<Value>(v)); }
    static constexpr int32_t bits_required_storage() { return 32; }
    static constexpr int32_t bits_required_transmission() { return 32; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(Signed32Test v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(int32_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed32Test::Value v) {
        switch (v) {
            case MIN: return "MIN";
            case MAX: return "MAX";
            case NEG_ONE: return "NEG_ONE";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 3> string_lookup_ = {
        std::make_pair(MIN, "MIN"),
        std::make_pair(MAX, "MAX"),
        std::make_pair(NEG_ONE, "NEG_ONE"),
    };
};

// Signed16Test Definition
struct Signed16Test {
    using UnderlyingType = int16_t;
    enum class Value : int16_t {
        MIN = (-32767 - 1),
        MAX = 32767,
        NEG_ONE = -1,
    };

    constexpr Signed16Test() : value_(Value((-32767 - 1))) { }
    constexpr Signed16Test(Value v) : value_(v) { }

    constexpr static Value MIN = Value::MIN;
    constexpr static Value MAX = Value::MAX;
    constexpr static Value NEG_ONE = Value::NEG_ONE;

    constexpr static std::array<Value, 3> Values = {
        MIN, MAX, NEG_ONE, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int16_t to_underlying() const { return static_cast<int16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = Signed16Test(); }

    static constexpr Signed16Test::Value default_value() { return Value((-32767 - 1)); }
    static constexpr int16_t min() { return (-32767 - 1); }
    static constexpr int16_t max() { return 32767; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr Signed16Test from_underlying_unsafe(int16_t v) { return Signed16Test(static_cast<Value>(v)); }
    static constexpr int16_t bits_required_storage() { return 16; }
    static constexpr int16_t bits_required_transmission() { return 16; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(Signed16Test v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(int16_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed16Test::Value v) {
        switch (v) {
            case MIN: return "MIN";
            case MAX: return "MAX";
            case NEG_ONE: return "NEG_ONE";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 3> string_lookup_ = {
        std::make_pair(MIN, "MIN"),
        std::make_pair(MAX, "MAX"),
        std::make_pair(NEG_ONE, "NEG_ONE"),
    };
};

// Signed8Test Definition
struct Signed8Test {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        V_INT_MIN = (-127 - 1),
        V_INT_MAX = 127,
        V_NEG_ONE = -1,
    };

    constexpr Signed8Test() : value_(Value((-127 - 1))) { }
    constexpr Signed8Test(Value v) : value_(v) { }

    constexpr static Value V_INT_MIN = Value::V_INT_MIN;
    constexpr static Value V_INT_MAX = Value::V_INT_MAX;
    constexpr static Value V_NEG_ONE = Value::V_NEG_ONE;

    constexpr static std::array<Value, 3> Values = {
        V_INT_MIN, V_INT_MAX, V_NEG_ONE, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = Signed8Test(); }

    static constexpr Signed8Test::Value default_value() { return Value((-127 - 1)); }
    static constexpr int8_t min() { return (-127 - 1); }
    static constexpr int8_t max() { return 127; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr Signed8Test from_underlying_unsafe(int8_t v) { return Signed8Test(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 8; }
    static constexpr int8_t bits_required_transmission() { return 8; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(Signed8Test v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(int8_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed8Test::Value v) {
        switch (v) {
            case V_INT_MIN: return "V_INT_MIN";
            case V_INT_MAX: return "V_INT_MAX";
            case V_NEG_ONE: return "V_NEG_ONE";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 3> string_lookup_ = {
        std::make_pair(V_INT_MIN, "V_INT_MIN"),
        std::make_pair(V_INT_MAX, "V_INT_MAX"),
        std::make_pair(V_NEG_ONE, "V_NEG_ONE"),
    };
};

// test_value Definition
struct test_value {
    using UnderlyingType = int32_t;
    enum class Value : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    constexpr test_value() : value_(Value(0)) { }
    constexpr test_value(Value v) : value_(v) { }

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr static std::array<Value, 3> Values = {
        A, B, C, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int32_t to_underlying() const { return static_cast<int32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_value(); }

    static constexpr test_value::Value default_value() { return Value(0); }
    static constexpr int32_t min() { return 0; }
    static constexpr int32_t max() { return 2; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_value from_underlying_unsafe(int32_t v) { return test_value(static_cast<Value>(v)); }
    static constexpr int32_t bits_required_storage() { return 3; }
    static constexpr int32_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_value v) { return (0 <= static_cast<int32_t>(v.value_)) && (static_cast<int32_t>(v.value_) <= 2); }
    static constexpr bool is_valid(int32_t v) { return (0 <= v) && (v <= 2); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const test_value::Value v) {
        switch (v) {
            case A: return "A";
            case B: return "B";
            case C: return "C";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 3> string_lookup_ = {
        std::make_pair(A, "A"),
        std::make_pair(B, "B"),
        std::make_pair(C, "C"),
    };
};

// HexDiagonal Definition
struct HexDiagonal {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    constexpr HexDiagonal() : value_(Value(0)) { }
    constexpr HexDiagonal(Value v) : value_(v) { }

    constexpr static Value NORTH = Value::NORTH;
    constexpr static Value NORTH_EAST = Value::NORTH_EAST;
    constexpr static Value SOUTH_EAST = Value::SOUTH_EAST;
    constexpr static Value SOUTH = Value::SOUTH;
    constexpr static Value SOUTH_WEST = Value::SOUTH_WEST;
    constexpr static Value NORTH_WEST = Value::NORTH_WEST;

    constexpr static std::array<Value, 6> Values = {
        NORTH, NORTH_EAST, SOUTH_EAST, SOUTH, SOUTH_WEST, NORTH_WEST, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = HexDiagonal(); }

    static constexpr HexDiagonal::Value default_value() { return Value(0); }
    static constexpr uint8_t min() { return 0; }
    static constexpr uint8_t max() { return 5; }
    static constexpr int count() { return 6; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr HexDiagonal from_underlying_unsafe(uint8_t v) { return HexDiagonal(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 3; }
    static constexpr uint8_t bits_required_transmission() { return 3; }
    static constexpr bool is_valid(HexDiagonal v) { return static_cast<uint8_t>(v.value_) <= 5; }
    static constexpr bool is_valid(uint8_t v) { return v <= 5; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const HexDiagonal::Value v) {
        switch (v) {
            case NORTH: return "NORTH";
            case NORTH_EAST: return "NORTH_EAST";
            case SOUTH_EAST: return "SOUTH_EAST";
            case SOUTH: return "SOUTH";
            case SOUTH_WEST: return "SOUTH_WEST";
            case NORTH_WEST: return "NORTH_WEST";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 6> string_lookup_ = {
        std::make_pair(NORTH, "NORTH"),
        std::make_pair(NORTH_EAST, "NORTH_EAST"),
        std::make_pair(SOUTH_EAST, "SOUTH_EAST"),
        std::make_pair(SOUTH, "SOUTH"),
        std::make_pair(SOUTH_WEST, "SOUTH_WEST"),
        std::make_pair(NORTH_WEST, "NORTH_WEST"),
    };
};

// NegativeTest1 Definition
struct NegativeTest1 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -2,
        B = -1,
        C = 0,
        D = 1,
    };

    constexpr NegativeTest1() : value_(Value(-2)) { }
    constexpr NegativeTest1(Value v) : value_(v) { }

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;
    constexpr static Value D = Value::D;

    constexpr static std::array<Value, 4> Values = {
        A, B, C, D, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = NegativeTest1(); }

    static constexpr NegativeTest1::Value default_value() { return Value(-2); }
    static constexpr int8_t min() { return -2; }
    static constexpr int8_t max() { return 1; }
    static constexpr int count() { return 4; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr NegativeTest1 from_underlying_unsafe(int8_t v) { return NegativeTest1(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 2; }
    static constexpr int8_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(NegativeTest1 v) { return (-2 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 1); }
    static constexpr bool is_valid(int8_t v) { return (-2 <= v) && (v <= 1); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest1::Value v) {
        switch (v) {
            case A: return "A";
            case B: return "B";
            case C: return "C";
            case D: return "D";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 4> string_lookup_ = {
        std::make_pair(A, "A"),
        std::make_pair(B, "B"),
        std::make_pair(C, "C"),
        std::make_pair(D, "D"),
    };
};

// NegativeTest2 Definition
struct NegativeTest2 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -3,
        B = -2,
        C = -1,
        D = 0,
    };

    constexpr NegativeTest2() : value_(Value(-3)) { }
    constexpr NegativeTest2(Value v) : value_(v) { }

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;
    constexpr static Value D = Value::D;

    constexpr static std::array<Value, 4> Values = {
        A, B, C, D, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = NegativeTest2(); }

    static constexpr NegativeTest2::Value default_value() { return Value(-3); }
    static constexpr int8_t min() { return -3; }
    static constexpr int8_t max() { return 0; }
    static constexpr int count() { return 4; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr NegativeTest2 from_underlying_unsafe(int8_t v) { return NegativeTest2(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 3; }
    static constexpr int8_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(NegativeTest2 v) { return (-3 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 0); }
    static constexpr bool is_valid(int8_t v) { return (-3 <= v) && (v <= 0); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest2::Value v) {
        switch (v) {
            case A: return "A";
            case B: return "B";
            case C: return "C";
            case D: return "D";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 4> string_lookup_ = {
        std::make_pair(A, "A"),
        std::make_pair(B, "B"),
        std::make_pair(C, "C"),
        std::make_pair(D, "D"),
    };
};

// NegativeTest3 Definition
struct NegativeTest3 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -3,
        B = 4,
    };

    constexpr NegativeTest3() : value_(Value(-3)) { }
    constexpr NegativeTest3(Value v) : value_(v) { }

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;

    constexpr static std::array<Value, 2> Values = {
        A, B, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = NegativeTest3(); }

    static constexpr NegativeTest3::Value default_value() { return Value(-3); }
    static constexpr int8_t min() { return -3; }
    static constexpr int8_t max() { return 4; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr NegativeTest3 from_underlying_unsafe(int8_t v) { return NegativeTest3(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 4; }
    static constexpr int8_t bits_required_transmission() { return 3; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(NegativeTest3 v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(int8_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest3::Value v) {
        switch (v) {
            case A: return "A";
            case B: return "B";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 2> string_lookup_ = {
        std::make_pair(A, "A"),
        std::make_pair(B, "B"),
    };
};

// NegativeTest4 Definition
struct NegativeTest4 {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = -4,
        B = 3,
    };

    constexpr NegativeTest4() : value_(Value(-4)) { }
    constexpr NegativeTest4(Value v) : value_(v) { }

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;

    constexpr static std::array<Value, 2> Values = {
        A, B, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = NegativeTest4(); }

    static constexpr NegativeTest4::Value default_value() { return Value(-4); }
    static constexpr int8_t min() { return -4; }
    static constexpr int8_t max() { return 3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr NegativeTest4 from_underlying_unsafe(int8_t v) { return NegativeTest4(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 3; }
    static constexpr int8_t bits_required_transmission() { return 3; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(NegativeTest4 v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(int8_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest4::Value v) {
        switch (v) {
            case A: return "A";
            case B: return "B";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 2> string_lookup_ = {
        std::make_pair(A, "A"),
        std::make_pair(B, "B"),
    };
};

// EmptyTest1Unsigned Definition
struct EmptyTest1Unsigned {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        A = 0,
    };

    constexpr EmptyTest1Unsigned() : value_(Value(0)) { }
    constexpr EmptyTest1Unsigned(Value v) : value_(v) { }

    constexpr static Value A = Value::A;

    constexpr static std::array<Value, 1> Values = {
        A, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = EmptyTest1Unsigned(); }

    static constexpr EmptyTest1Unsigned::Value default_value() { return Value(0); }
    static constexpr uint8_t min() { return 0; }
    static constexpr uint8_t max() { return 0; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr EmptyTest1Unsigned from_underlying_unsafe(uint8_t v) { return EmptyTest1Unsigned(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 1; }
    static constexpr uint8_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(EmptyTest1Unsigned v) { return static_cast<uint8_t>(v.value_) <= 0; }
    static constexpr bool is_valid(uint8_t v) { return v <= 0; }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const EmptyTest1Unsigned::Value v) {
        switch (v) {
            case A: return "A";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 1> string_lookup_ = {
        std::make_pair(A, "A"),
    };
};

// EmptyTest1Signed Definition
struct EmptyTest1Signed {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = 0,
    };

    constexpr EmptyTest1Signed() : value_(Value(0)) { }
    constexpr EmptyTest1Signed(Value v) : value_(v) { }

    constexpr static Value A = Value::A;

    constexpr static std::array<Value, 1> Values = {
        A, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = EmptyTest1Signed(); }

    static constexpr EmptyTest1Signed::Value default_value() { return Value(0); }
    static constexpr int8_t min() { return 0; }
    static constexpr int8_t max() { return 0; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr EmptyTest1Signed from_underlying_unsafe(int8_t v) { return EmptyTest1Signed(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 1; }
    static constexpr int8_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(EmptyTest1Signed v) { return (0 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 0); }
    static constexpr bool is_valid(int8_t v) { return (0 <= v) && (v <= 0); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const EmptyTest1Signed::Value v) {
        switch (v) {
            case A: return "A";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 1> string_lookup_ = {
        std::make_pair(A, "A"),
    };
};

// SingleTest1Unsigned Definition
struct SingleTest1Unsigned {
    using UnderlyingType = uint8_t;
    enum class Value : uint8_t {
        A = 4,
    };

    constexpr SingleTest1Unsigned() : value_(Value(4)) { }
    constexpr SingleTest1Unsigned(Value v) : value_(v) { }

    constexpr static Value A = Value::A;

    constexpr static std::array<Value, 1> Values = {
        A, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr uint8_t to_underlying() const { return static_cast<uint8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = SingleTest1Unsigned(); }

    static constexpr SingleTest1Unsigned::Value default_value() { return Value(4); }
    static constexpr uint8_t min() { return 4; }
    static constexpr uint8_t max() { return 4; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr SingleTest1Unsigned from_underlying_unsafe(uint8_t v) { return SingleTest1Unsigned(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 3; }
    static constexpr uint8_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(SingleTest1Unsigned v) { return (4 <= static_cast<uint8_t>(v.value_)) && (static_cast<uint8_t>(v.value_) <= 4); }
    static constexpr bool is_valid(uint8_t v) { return (4 <= v) && (v <= 4); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const SingleTest1Unsigned::Value v) {
        switch (v) {
            case A: return "A";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 1> string_lookup_ = {
        std::make_pair(A, "A"),
    };
};

// SingleTest1Signed Definition
struct SingleTest1Signed {
    using UnderlyingType = int8_t;
    enum class Value : int8_t {
        A = 4,
    };

    constexpr SingleTest1Signed() : value_(Value(4)) { }
    constexpr SingleTest1Signed(Value v) : value_(v) { }

    constexpr static Value A = Value::A;

    constexpr static std::array<Value, 1> Values = {
        A, 
    };

    constexpr Value value() const { return value_; }
    constexpr operator Value() const { return value_; }
    explicit operator bool() = delete;

    constexpr int8_t to_underlying() const { return static_cast<int8_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = SingleTest1Signed(); }

    static constexpr SingleTest1Signed::Value default_value() { return Value(4); }
    static constexpr int8_t min() { return 4; }
    static constexpr int8_t max() { return 4; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr SingleTest1Signed from_underlying_unsafe(int8_t v) { return SingleTest1Signed(static_cast<Value>(v)); }
    static constexpr int8_t bits_required_storage() { return 4; }
    static constexpr int8_t bits_required_transmission() { return 1; }
    static constexpr bool is_valid(SingleTest1Signed v) { return (4 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 4); }
    static constexpr bool is_valid(int8_t v) { return (4 <= v) && (v <= 4); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const SingleTest1Signed::Value v) {
        switch (v) {
            case A: return "A";
            default: return "";
        }
    }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Value> from_string(const char* str) {
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, default_value());
    }

private:
    Value value_;
    constexpr static std::array<std::pair<Value,const char*>, 1> string_lookup_ = {
        std::make_pair(A, "A"),
    };
};

// test_flags Definition
struct test_flags {
    using UnderlyingType = uint32_t;
    enum class Value : uint32_t {
        B = 1,
        C = 2,
    };

    constexpr test_flags() : value_(Value(0)) { }
    constexpr test_flags(Value v) : value_(v) { }

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr static std::array<Value, 2> Values = {
        B, C, 
    };

    constexpr Value value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint32_t to_underlying() const { return static_cast<uint32_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_flags(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint32_t>(value_) & static_cast<uint32_t>(v)) == static_cast<uint32_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint32_t>(value_) & (~static_cast<uint32_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint32_t>(value_) ^ static_cast<uint32_t>(v)); }
    constexpr bool all() const { return static_cast<uint32_t>(value_) >= 0x3; }
    constexpr bool any() const { return static_cast<uint32_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint32_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_single() const { uint32_t n = static_cast<uint32_t>(value_); return n && !(n & (n - 1)); }

    static constexpr test_flags::Value default_value() { return Value(0); }
    static constexpr uint32_t min() { return 0; }
    static constexpr uint32_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_flags from_underlying_unsafe(uint32_t v) { return test_flags(static_cast<Value>(v)); }
    static constexpr uint32_t bits_required_storage() { return 2; }
    static constexpr uint32_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_flags v) { return static_cast<uint32_t>(v.value_) <= 3; }
    static constexpr bool is_valid(uint32_t v) { return v <= 3; }

private:
    Value value_;
};

// test_flags Operator Overloads
constexpr bool operator==(const test_flags& a, const test_flags& b) { return a.value() == b.value(); }
constexpr bool operator!=(const test_flags& a, const test_flags& b) { return a.value() != b.value(); }
constexpr test_flags::Value operator~(const test_flags::Value a) { return static_cast<test_flags::Value>(~static_cast<uint32_t>(a)); }
constexpr test_flags::Value operator|(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator&(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator^(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
constexpr test_flags operator~(const test_flags a) { return ~a.value(); }
constexpr test_flags operator|(const test_flags a, const test_flags b) { return a.value() | b.value(); }
constexpr test_flags operator&(const test_flags a, const test_flags b) { return a.value() & b.value(); }
constexpr test_flags operator^(const test_flags a, const test_flags b) { return a.value() ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator|=(test_flags& a, const test_flags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator&=(test_flags& a, const test_flags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator^=(test_flags& a, const test_flags b) { a = a ^ b; return a; }

// test_nodefault Definition
struct test_nodefault {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        B = 1,
        C = 2,
    };

    constexpr test_nodefault() : value_(Value(0)) { }
    constexpr test_nodefault(Value v) : value_(v) { }

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr static std::array<Value, 2> Values = {
        B, C, 
    };

    constexpr Value value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = test_nodefault(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 0x3; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_single() const { uint16_t n = static_cast<uint16_t>(value_); return n && !(n & (n - 1)); }

    static constexpr test_nodefault::Value default_value() { return Value(0); }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_nodefault from_underlying_unsafe(uint16_t v) { return test_nodefault(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 2; }
    static constexpr uint16_t bits_required_transmission() { return 2; }
    static constexpr bool is_valid(test_nodefault v) { return static_cast<uint16_t>(v.value_) <= 3; }
    static constexpr bool is_valid(uint16_t v) { return v <= 3; }

private:
    Value value_;
};

// test_nodefault Operator Overloads
constexpr bool operator==(const test_nodefault& a, const test_nodefault& b) { return a.value() == b.value(); }
constexpr bool operator!=(const test_nodefault& a, const test_nodefault& b) { return a.value() != b.value(); }
constexpr test_nodefault::Value operator~(const test_nodefault::Value a) { return static_cast<test_nodefault::Value>(~static_cast<uint16_t>(a)); }
constexpr test_nodefault::Value operator|(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator&(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator^(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr test_nodefault operator~(const test_nodefault a) { return ~a.value(); }
constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b) { return a.value() | b.value(); }
constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b) { return a.value() & b.value(); }
constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b) { return a.value() ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator|=(test_nodefault& a, const test_nodefault b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator&=(test_nodefault& a, const test_nodefault b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator^=(test_nodefault& a, const test_nodefault b) { a = a ^ b; return a; }

// TestSparseFlags Definition
struct TestSparseFlags {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        B = 1,
        C = 4,
        D = 16,
    };

    constexpr TestSparseFlags() : value_(Value(0)) { }
    constexpr TestSparseFlags(Value v) : value_(v) { }

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;
    constexpr static Value D = Value::D;

    constexpr static std::array<Value, 3> Values = {
        B, C, D, 
    };

    constexpr Value value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = TestSparseFlags(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 0x15; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_single() const { uint16_t n = static_cast<uint16_t>(value_); return n && !(n & (n - 1)); }

    static constexpr TestSparseFlags::Value default_value() { return Value(0); }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x15; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return false; }
    static constexpr TestSparseFlags from_underlying_unsafe(uint16_t v) { return TestSparseFlags(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 5; }
    static constexpr uint16_t bits_required_transmission() { return 5; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(TestSparseFlags v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == v.value()) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_valid(uint16_t v) { for(std::size_t i = 0; i < Values.size(); i++) { auto& val = Values[i]; if(val == Value(v)) return true; } return false; }

private:
    Value value_;
};

// TestSparseFlags Operator Overloads
constexpr bool operator==(const TestSparseFlags& a, const TestSparseFlags& b) { return a.value() == b.value(); }
constexpr bool operator!=(const TestSparseFlags& a, const TestSparseFlags& b) { return a.value() != b.value(); }
constexpr TestSparseFlags::Value operator~(const TestSparseFlags::Value a) { return static_cast<TestSparseFlags::Value>(~static_cast<uint16_t>(a)); }
constexpr TestSparseFlags::Value operator|(const TestSparseFlags::Value a, const TestSparseFlags::Value b) { return static_cast<TestSparseFlags::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr TestSparseFlags::Value operator&(const TestSparseFlags::Value a, const TestSparseFlags::Value b) { return static_cast<TestSparseFlags::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr TestSparseFlags::Value operator^(const TestSparseFlags::Value a, const TestSparseFlags::Value b) { return static_cast<TestSparseFlags::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr TestSparseFlags operator~(const TestSparseFlags a) { return ~a.value(); }
constexpr TestSparseFlags operator|(const TestSparseFlags a, const TestSparseFlags b) { return a.value() | b.value(); }
constexpr TestSparseFlags operator&(const TestSparseFlags a, const TestSparseFlags b) { return a.value() & b.value(); }
constexpr TestSparseFlags operator^(const TestSparseFlags a, const TestSparseFlags b) { return a.value() ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator|=(TestSparseFlags& a, const TestSparseFlags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator&=(TestSparseFlags& a, const TestSparseFlags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator^=(TestSparseFlags& a, const TestSparseFlags b) { a = a ^ b; return a; }

// TestSingleFlag Definition
struct TestSingleFlag {
    using UnderlyingType = uint16_t;
    enum class Value : uint16_t {
        C = 4,
    };

    constexpr TestSingleFlag() : value_(Value(0)) { }
    constexpr TestSingleFlag(Value v) : value_(v) { }

    constexpr static Value C = Value::C;

    constexpr static std::array<Value, 1> Values = {
        C, 
    };

    constexpr Value value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    constexpr uint16_t to_underlying() const { return static_cast<uint16_t>(value_); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_default() { *this = TestSingleFlag(); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void reset_zero() { value_ = static_cast<Value>(0); }
    constexpr bool test(Value v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void unset(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void flip(Value v) { value_ = static_cast<Value>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool all() const { return static_cast<uint16_t>(value_) >= 0x4; }
    constexpr bool any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool is_single() const { uint16_t n = static_cast<uint16_t>(value_); return n && !(n & (n - 1)); }

    static constexpr TestSingleFlag::Value default_value() { return Value(0); }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x4; }
    static constexpr int count() { return 1; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr TestSingleFlag from_underlying_unsafe(uint16_t v) { return TestSingleFlag(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 3; }
    static constexpr uint16_t bits_required_transmission() { return 3; }
    static constexpr bool is_valid(TestSingleFlag v) { return static_cast<uint16_t>(v.value_) <= 4; }
    static constexpr bool is_valid(uint16_t v) { return v <= 4; }

private:
    Value value_;
};

// TestSingleFlag Operator Overloads
constexpr bool operator==(const TestSingleFlag& a, const TestSingleFlag& b) { return a.value() == b.value(); }
constexpr bool operator!=(const TestSingleFlag& a, const TestSingleFlag& b) { return a.value() != b.value(); }
constexpr TestSingleFlag::Value operator~(const TestSingleFlag::Value a) { return static_cast<TestSingleFlag::Value>(~static_cast<uint16_t>(a)); }
constexpr TestSingleFlag::Value operator|(const TestSingleFlag::Value a, const TestSingleFlag::Value b) { return static_cast<TestSingleFlag::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr TestSingleFlag::Value operator&(const TestSingleFlag::Value a, const TestSingleFlag::Value b) { return static_cast<TestSingleFlag::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr TestSingleFlag::Value operator^(const TestSingleFlag::Value a, const TestSingleFlag::Value b) { return static_cast<TestSingleFlag::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr TestSingleFlag operator~(const TestSingleFlag a) { return ~a.value(); }
constexpr TestSingleFlag operator|(const TestSingleFlag a, const TestSingleFlag b) { return a.value() | b.value(); }
constexpr TestSingleFlag operator&(const TestSingleFlag a, const TestSingleFlag b) { return a.value() & b.value(); }
constexpr TestSingleFlag operator^(const TestSingleFlag a, const TestSingleFlag b) { return a.value() ^ b.value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator|=(TestSingleFlag& a, const TestSingleFlag b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator&=(TestSingleFlag& a, const TestSingleFlag b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator^=(TestSingleFlag& a, const TestSingleFlag b) { a = a ^ b; return a; }

} // namespace enums

// enums::Unsigned64Test Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::Unsigned64Test::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Unsigned64Test;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::Unsigned64Test> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Unsigned64Test;
};
// enums::Signed64Test Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed64Test::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed64Test;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed64Test> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed64Test;
};
// enums::Signed32Test Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed32Test::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed32Test;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed32Test> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed32Test;
};
// enums::Signed16Test Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed16Test::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed16Test;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed16Test> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed16Test;
};
// enums::Signed8Test Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed8Test::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed8Test;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::Signed8Test> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::Signed8Test;
};
// enums::test_value Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_value::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::test_value;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::test_value;
};
// enums::HexDiagonal Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::HexDiagonal::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::HexDiagonal;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::HexDiagonal> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::HexDiagonal;
};
// enums::NegativeTest1 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest1::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest1;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest1> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest1;
};
// enums::NegativeTest2 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest2::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest2;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest2> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest2;
};
// enums::NegativeTest3 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest3::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest3;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest3> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest3;
};
// enums::NegativeTest4 Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest4::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest4;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::NegativeTest4> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::NegativeTest4;
};
// enums::EmptyTest1Unsigned Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Unsigned::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Unsigned;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Unsigned> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Unsigned;
};
// enums::EmptyTest1Signed Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Signed::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Signed;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::EmptyTest1Signed> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::EmptyTest1Signed;
};
// enums::SingleTest1Unsigned Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Unsigned::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Unsigned;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Unsigned> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Unsigned;
};
// enums::SingleTest1Signed Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Signed::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Signed;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::SingleTest1Signed> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = true;
    static constexpr bool enumbra_flags_enum = false;
    using base_type = enums::SingleTest1Signed;
};
// enums::test_flags Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_flags::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_flags;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_flags> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_flags;
};
// enums::test_nodefault Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::test_nodefault::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_nodefault;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::test_nodefault> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::test_nodefault;
};
// enums::TestSparseFlags Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSparseFlags::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSparseFlags;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSparseFlags> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSparseFlags;
};
// enums::TestSingleFlag Template Specializations
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSingleFlag::Value> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = true;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSingleFlag;
};
template<> struct enumbra::detail::enumbra_base_helper<enums::TestSingleFlag> {
    static constexpr bool enumbra_type = true;
    static constexpr bool enumbra_enum_class = false;
    static constexpr bool enumbra_value_enum = false;
    static constexpr bool enumbra_flags_enum = true;
    using base_type = enums::TestSingleFlag;
};
