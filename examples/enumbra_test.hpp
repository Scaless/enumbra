// THIS FILE WAS GENERATED BY A TOOL (haha)
// Direct your feedback and monetary donations to: https://github.com/Scaless/enumbra
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated.
// Generated by enumbra v0.1.0

// You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should put it in your enumbra_config.json file!

#pragma once

#include <array>
#include <cstdint>

#if !defined(ENUMBRA_REQUIRED_MACROS_VERSION)
#define ENUMBRA_REQUIRED_MACROS_VERSION 3

// Find out what language version we're using
#if ((defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)) || (__cplusplus >= 202002L)
#define ENUMBRA_CPP_VERSION 20
#elif ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)) || (__cplusplus >= 201703L)
#define ENUMBRA_CPP_VERSION 17
#elif ((defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)) || (__cplusplus >= 201402L)
#define ENUMBRA_CPP_VERSION 14
#elif ((defined(_MSC_VER) && _MSC_VER >= 1700 /*VS2012*/)) || (__cplusplus >= 201103L)
#define ENUMBRA_CPP_VERSION 11
#else
#error enumbra generated headers require a C++11 or higher compiler.
#endif

// Non-const constexpr functions were added in C++14
#if __cpp_constexpr >= 201304L
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC constexpr
#else
#define ENUMBRA_CONSTEXPR_NONCONSTFUNC inline
#endif

#else // check existing version supported
#if (ENUMBRA_REQUIRED_MACROS_VERSION + 0) == 0
#error ENUMBRA_REQUIRED_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) < 3
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_REQUIRED_MACROS_VERSION + 0) > 3
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_REQUIRED_MACROS_VERSION

#if !defined(ENUMBRA_OPTIONAL_MACROS_VERSION)
#define ENUMBRA_OPTIONAL_MACROS_VERSION 4

// Bit field storage helper
#define ENUMBRA_PACK_UNINITIALIZED(Enum, Name) Enum::_enum Name : ::enumbra::bits_required_storage<Enum>();
#define ENUMBRA_INIT(Name, InitValue) Name(enumbra::enumbra_base_t<decltype(Name)>(InitValue)._value())
#define ENUMBRA_INIT_DEFAULT(Name) Name(enumbra::enumbra_base_t<decltype(Name)>()._value())

#if ENUMBRA_CPP_VERSION >= 20
// Bit field storage helper with type-checked member initialization
#define ENUMBRA_PACK_INIT(Enum, Name, InitValue) Enum::_enum Name : ::enumbra::bits_required_storage<Enum>() { enumbra::enumbra_base_t<Enum>(InitValue)._value() };
// Bit field storage helper with default value initialization
#define ENUMBRA_PACK_INIT_DEFAULT(Enum, Name) Enum::_enum Name : ::enumbra::bits_required_storage<Enum>() { Enum()._value() };
#endif

#else // check existing version supported
#if (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) == 0
#error ENUMBRA_OPTIONAL_MACROS_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) < 4
#error An included header was generated using a newer version of enumbra. Regenerate your headers using the same version.
#elif (ENUMBRA_OPTIONAL_MACROS_VERSION + 0) > 4
#error An included header was generated using an older version of enumbra. Regenerate your headers using the same version.
#endif // end check existing version supported
#endif // ENUMBRA_OPTIONAL_MACROS_VERSION


#if !defined(ENUMBRA_BASE_TEMPLATES_VERSION)
#define ENUMBRA_BASE_TEMPLATES_VERSION 5
namespace enumbra {
    namespace detail {
        // Type info
        template<bool is_enumbra, bool is_enum_class, bool is_value_enum, bool is_flags_enum>
        struct type_info { 
            static constexpr bool enumbra_type = is_enumbra;
            static constexpr bool enumbra_enum_class = is_enum_class;
            static constexpr bool enumbra_value_enum = is_value_enum;
            static constexpr bool enumbra_flags_enum = is_flags_enum;
        };

        // Value enum info
        template<typename underlying_type, underlying_type min_v, underlying_type max_v, typename count_type, count_type count_v,
            bool is_contiguous_v, int bits_required_storage_v, int bits_required_transmission_v>
        struct value_enum_info {
            static constexpr underlying_type min = min_v;
            static constexpr underlying_type max = max_v;
            static constexpr count_type count = count_v;
            static constexpr bool is_contiguous = is_contiguous_v;
            static constexpr int bits_required_storage = bits_required_storage_v;
            static constexpr int bits_required_transmission = bits_required_transmission_v;
        };

        // Flags enum info
        template<typename underlying_type, underlying_type min_v, underlying_type max_v, typename count_type, count_type count_v,
            bool is_contiguous_v, int bits_required_storage_v, int bits_required_transmission_v>
        struct flags_enum_info {
            static constexpr underlying_type min = min_v;
            static constexpr underlying_type max = max_v;
            static constexpr count_type count = count_v;
            static constexpr bool is_contiguous = is_contiguous_v;
            static constexpr int bits_required_storage = bits_required_storage_v;
            static constexpr int bits_required_transmission = bits_required_transmission_v;
        };
        
        // Default template for non-enumbra types
        template<class T>
        struct base_helper : type_info<false, false, false, false> { using base_type = T; };
        template<class T>
        struct value_enum_helper;
        template<class T>
        struct flags_enum_helper;

        // Constexpr string compare
        template<class T> constexpr bool streq(T* a, T* b) { return *a == *b && (*a == '\0' || streq(a + 1, b + 1)); }
    } // end namespace enumbra::detail
    template<class T> using enumbra_base_t = typename detail::base_helper<T>::base_type;
    template<class T> constexpr bool is_enumbra_type() { return detail::base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_type(T) { return detail::base_helper<T>::enumbra_type; }
    template<class T> constexpr bool is_enumbra_struct() { return is_enumbra_type<T>() && !detail::base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_struct(T) { return is_enumbra_type<T>() && !detail::base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum() { return is_enumbra_type<T>() && detail::base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_scoped_enum(T) { return is_enumbra_type<T>() && detail::base_helper<T>::enumbra_enum_class; }
    template<class T> constexpr bool is_enumbra_value_enum() { return is_enumbra_type<T>() && detail::base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_value_enum(T) { return is_enumbra_type<T>() && detail::base_helper<T>::enumbra_value_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum() { return is_enumbra_type<T>() && detail::base_helper<T>::enumbra_flags_enum; }
    template<class T> constexpr bool is_enumbra_flags_enum(T) { return is_enumbra_type<T>() && detail::base_helper<T>::enumbra_flags_enum; }
    
    template<class T, std::enable_if_t<is_enumbra_value_enum<T>(), T>* = nullptr>
    constexpr auto min() { return detail::value_enum_helper<T>::min; }
    template<class T, std::enable_if_t<is_enumbra_flags_enum<T>(), T>* = nullptr>
    constexpr auto min() { return detail::flags_enum_helper<T>::min; }
    template<class T, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr auto min() = delete;

    template<class T, std::enable_if_t<is_enumbra_value_enum<T>(), T>* = nullptr>
    constexpr auto max() { return detail::value_enum_helper<T>::max; }
    template<class T, std::enable_if_t<is_enumbra_flags_enum<T>(), T>* = nullptr>
    constexpr auto max() { return detail::flags_enum_helper<T>::max; }
    template<class T, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr auto max() = delete;

    template<class T, std::enable_if_t<is_enumbra_value_enum<T>(), T>* = nullptr>
    constexpr auto count() { return detail::value_enum_helper<T>::count; }
    template<class T, std::enable_if_t<is_enumbra_flags_enum<T>(), T>* = nullptr>
    constexpr auto count() { return detail::flags_enum_helper<T>::count; }
    template<class T, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr auto count() = delete;

    template<class T, std::enable_if_t<is_enumbra_value_enum<T>(), T>* = nullptr>
    constexpr auto is_contiguous() { return detail::value_enum_helper<T>::is_contiguous; }
    template<class T, std::enable_if_t<is_enumbra_flags_enum<T>(), T>* = nullptr>
    constexpr auto is_contiguous() { return detail::flags_enum_helper<T>::is_contiguous; }
    template<class T, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr auto is_contiguous() = delete;

    template<class T, std::enable_if_t<is_enumbra_value_enum<T>(), T>* = nullptr>
    constexpr auto bits_required_storage() { return detail::value_enum_helper<T>::bits_required_storage; }
    template<class T, std::enable_if_t<is_enumbra_flags_enum<T>(), T>* = nullptr>
    constexpr auto bits_required_storage() { return detail::flags_enum_helper<T>::bits_required_storage; }
    template<class T, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr auto bits_required_storage() = delete;

    template<class T, std::enable_if_t<is_enumbra_value_enum<T>(), T>* = nullptr>
    constexpr auto bits_required_transmission() { return detail::value_enum_helper<T>::bits_required_transmission; }
    template<class T, std::enable_if_t<is_enumbra_flags_enum<T>(), T>* = nullptr>
    constexpr auto bits_required_transmission() { return detail::flags_enum_helper<T>::bits_required_transmission; }
    template<class T, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr auto bits_required_transmission() = delete;

    template<class T, class underlying_type = detail::base_helper<T>::base_type::_underlying_type, std::enable_if_t<is_enumbra_type<T>(), T>* = nullptr>
    constexpr T from_underlying_unsafe(underlying_type e) { return T(static_cast<detail::base_helper<T>::base_type::_enum>(e)); }
    template<class T, class underlying_type = detail::base_helper<T>::base_type::_underlying_type, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr T from_underlying_unsafe(underlying_type e) = delete;

    template<class T, class underlying_type = detail::base_helper<T>::base_type::_underlying_type, std::enable_if_t<is_enumbra_type<T>(), T>* = nullptr>
    constexpr underlying_type to_underlying(T e) { return static_cast<underlying_type>(e._value()); }
    template<class T, class underlying_type = detail::base_helper<T>::base_type::_underlying_type, std::enable_if_t<!is_enumbra_type<T>(), T>* = nullptr>
    constexpr underlying_type to_underlying(T e) = delete;

} // end namespace enumbra
#else // check existing version supported
#if (ENUMBRA_BASE_TEMPLATES_VERSION + 0) == 0
#error ENUMBRA_BASE_TEMPLATES_VERSION has been defined without a proper version number. Check your build system.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) < 4
#error An included header was generated using a newer version of enumbra. Regenerate your headers using same version of enumbra.
#elif (ENUMBRA_BASE_TEMPLATES_VERSION + 0) > 4
#error An included header was generated using an older version of enumbra. Regenerate your headers using same version of enumbra.
#endif // check existing version supported
#endif // ENUMBRA_BASE_TEMPLATES_VERSION

namespace enums {

    // Begin Default Templates
    template<class T>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, typename T::_enum> from_string(const char* str) = delete;
    // End Default Templates

// test_string_parse Definition
struct test_string_parse {
    using _underlying_type = int64_t;
    enum class _enum : int64_t {
        B = 1,
        C = -1,
        D = 511,
        E = 9223372036854775807,
        F = 341,
    };

    constexpr test_string_parse() : value_(_enum(-1)) { }
    constexpr test_string_parse(_enum v) : value_(v) { }

    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;
    static constexpr _enum D = _enum::D;
    static constexpr _enum E = _enum::E;
    static constexpr _enum F = _enum::F;

    static constexpr std::array<_enum, 5> _values = {{
        B, C, D, E, F, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(test_string_parse v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int64_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const test_string_parse::_enum v) {
        switch (v) {
            case test_string_parse::B: return "B";
            case test_string_parse::C: return "C";
            case test_string_parse::D: return "D";
            case test_string_parse::E: return "E";
            case test_string_parse::F: return "F";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, test_string_parse::_enum> from_string<test_string_parse>(const char* str) {
        constexpr std::array<std::pair<test_string_parse::_enum,const char*>, 5> string_lookup_ = {{
            std::make_pair(test_string_parse::B, "B"),
            std::make_pair(test_string_parse::C, "C"),
            std::make_pair(test_string_parse::D, "D"),
            std::make_pair(test_string_parse::E, "E"),
            std::make_pair(test_string_parse::F, "F"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, test_string_parse::_enum());
    }

// Unsigned64Test Definition
struct Unsigned64Test {
    using _underlying_type = uint64_t;
    enum class _enum : uint64_t {
        MAX = 0xFFFFFFFFFFFFFFFF,
        MIN = 0,
        V_UINT16_MAX = 0xFFFF,
        V_UINT32_MAX = 0xFFFFFFFF,
    };

    constexpr Unsigned64Test() : value_(_enum(0)) { }
    constexpr Unsigned64Test(_enum v) : value_(v) { }

    static constexpr _enum MAX = _enum::MAX;
    static constexpr _enum MIN = _enum::MIN;
    static constexpr _enum V_UINT16_MAX = _enum::V_UINT16_MAX;
    static constexpr _enum V_UINT32_MAX = _enum::V_UINT32_MAX;

    static constexpr std::array<_enum, 4> _values = {{
        MAX, MIN, V_UINT16_MAX, V_UINT32_MAX, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(Unsigned64Test v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(uint64_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Unsigned64Test::_enum v) {
        switch (v) {
            case Unsigned64Test::MAX: return "MAX";
            case Unsigned64Test::MIN: return "MIN";
            case Unsigned64Test::V_UINT16_MAX: return "V_UINT16_MAX";
            case Unsigned64Test::V_UINT32_MAX: return "V_UINT32_MAX";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Unsigned64Test::_enum> from_string<Unsigned64Test>(const char* str) {
        constexpr std::array<std::pair<Unsigned64Test::_enum,const char*>, 4> string_lookup_ = {{
            std::make_pair(Unsigned64Test::MAX, "MAX"),
            std::make_pair(Unsigned64Test::MIN, "MIN"),
            std::make_pair(Unsigned64Test::V_UINT16_MAX, "V_UINT16_MAX"),
            std::make_pair(Unsigned64Test::V_UINT32_MAX, "V_UINT32_MAX"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, Unsigned64Test::_enum());
    }

// Signed64Test Definition
struct Signed64Test {
    using _underlying_type = int64_t;
    enum class _enum : int64_t {
        MIN = (-9223372036854775807 - 1),
        MAX = 9223372036854775807,
        NEG_ONE = -1,
    };

    constexpr Signed64Test() : value_(_enum((-9223372036854775807 - 1))) { }
    constexpr Signed64Test(_enum v) : value_(v) { }

    static constexpr _enum MIN = _enum::MIN;
    static constexpr _enum MAX = _enum::MAX;
    static constexpr _enum NEG_ONE = _enum::NEG_ONE;

    static constexpr std::array<_enum, 3> _values = {{
        MIN, MAX, NEG_ONE, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(Signed64Test v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int64_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed64Test::_enum v) {
        switch (v) {
            case Signed64Test::MIN: return "MIN";
            case Signed64Test::MAX: return "MAX";
            case Signed64Test::NEG_ONE: return "NEG_ONE";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Signed64Test::_enum> from_string<Signed64Test>(const char* str) {
        constexpr std::array<std::pair<Signed64Test::_enum,const char*>, 3> string_lookup_ = {{
            std::make_pair(Signed64Test::MIN, "MIN"),
            std::make_pair(Signed64Test::MAX, "MAX"),
            std::make_pair(Signed64Test::NEG_ONE, "NEG_ONE"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, Signed64Test::_enum());
    }

// Signed32Test Definition
struct Signed32Test {
    using _underlying_type = int32_t;
    enum class _enum : int32_t {
        MIN = (-2147483647 - 1),
        MAX = 2147483647,
        NEG_ONE = -1,
    };

    constexpr Signed32Test() : value_(_enum((-2147483647 - 1))) { }
    constexpr Signed32Test(_enum v) : value_(v) { }

    static constexpr _enum MIN = _enum::MIN;
    static constexpr _enum MAX = _enum::MAX;
    static constexpr _enum NEG_ONE = _enum::NEG_ONE;

    static constexpr std::array<_enum, 3> _values = {{
        MIN, MAX, NEG_ONE, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(Signed32Test v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int32_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed32Test::_enum v) {
        switch (v) {
            case Signed32Test::MIN: return "MIN";
            case Signed32Test::MAX: return "MAX";
            case Signed32Test::NEG_ONE: return "NEG_ONE";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Signed32Test::_enum> from_string<Signed32Test>(const char* str) {
        constexpr std::array<std::pair<Signed32Test::_enum,const char*>, 3> string_lookup_ = {{
            std::make_pair(Signed32Test::MIN, "MIN"),
            std::make_pair(Signed32Test::MAX, "MAX"),
            std::make_pair(Signed32Test::NEG_ONE, "NEG_ONE"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, Signed32Test::_enum());
    }

// Signed16Test Definition
struct Signed16Test {
    using _underlying_type = int16_t;
    enum class _enum : int16_t {
        MIN = (-32767 - 1),
        MAX = 32767,
        NEG_ONE = -1,
    };

    constexpr Signed16Test() : value_(_enum((-32767 - 1))) { }
    constexpr Signed16Test(_enum v) : value_(v) { }

    static constexpr _enum MIN = _enum::MIN;
    static constexpr _enum MAX = _enum::MAX;
    static constexpr _enum NEG_ONE = _enum::NEG_ONE;

    static constexpr std::array<_enum, 3> _values = {{
        MIN, MAX, NEG_ONE, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(Signed16Test v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int16_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed16Test::_enum v) {
        switch (v) {
            case Signed16Test::MIN: return "MIN";
            case Signed16Test::MAX: return "MAX";
            case Signed16Test::NEG_ONE: return "NEG_ONE";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Signed16Test::_enum> from_string<Signed16Test>(const char* str) {
        constexpr std::array<std::pair<Signed16Test::_enum,const char*>, 3> string_lookup_ = {{
            std::make_pair(Signed16Test::MIN, "MIN"),
            std::make_pair(Signed16Test::MAX, "MAX"),
            std::make_pair(Signed16Test::NEG_ONE, "NEG_ONE"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, Signed16Test::_enum());
    }

// Signed8Test Definition
struct Signed8Test {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        V_INT_MIN = (-127 - 1),
        V_INT_MAX = 127,
        V_NEG_ONE = -1,
    };

    constexpr Signed8Test() : value_(_enum((-127 - 1))) { }
    constexpr Signed8Test(_enum v) : value_(v) { }

    static constexpr _enum V_INT_MIN = _enum::V_INT_MIN;
    static constexpr _enum V_INT_MAX = _enum::V_INT_MAX;
    static constexpr _enum V_NEG_ONE = _enum::V_NEG_ONE;

    static constexpr std::array<_enum, 3> _values = {{
        V_INT_MIN, V_INT_MAX, V_NEG_ONE, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(Signed8Test v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int8_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const Signed8Test::_enum v) {
        switch (v) {
            case Signed8Test::V_INT_MIN: return "V_INT_MIN";
            case Signed8Test::V_INT_MAX: return "V_INT_MAX";
            case Signed8Test::V_NEG_ONE: return "V_NEG_ONE";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, Signed8Test::_enum> from_string<Signed8Test>(const char* str) {
        constexpr std::array<std::pair<Signed8Test::_enum,const char*>, 3> string_lookup_ = {{
            std::make_pair(Signed8Test::V_INT_MIN, "V_INT_MIN"),
            std::make_pair(Signed8Test::V_INT_MAX, "V_INT_MAX"),
            std::make_pair(Signed8Test::V_NEG_ONE, "V_NEG_ONE"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, Signed8Test::_enum());
    }

// test_value Definition
struct test_value {
    using _underlying_type = int32_t;
    enum class _enum : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    constexpr test_value() : value_(_enum(0)) { }
    constexpr test_value(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;
    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;

    static constexpr std::array<_enum, 3> _values = {{
        A, B, C, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(test_value v) { return (0 <= static_cast<int32_t>(v.value_)) && (static_cast<int32_t>(v.value_) <= 2); }
    static constexpr bool _is_valid(int32_t v) { return (0 <= v) && (v <= 2); }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const test_value::_enum v) {
        switch (v) {
            case test_value::A: return "A";
            case test_value::B: return "B";
            case test_value::C: return "C";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, test_value::_enum> from_string<test_value>(const char* str) {
        constexpr std::array<std::pair<test_value::_enum,const char*>, 3> string_lookup_ = {{
            std::make_pair(test_value::A, "A"),
            std::make_pair(test_value::B, "B"),
            std::make_pair(test_value::C, "C"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, test_value::_enum());
    }

// HexDiagonal Definition
struct HexDiagonal {
    using _underlying_type = uint8_t;
    enum class _enum : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    constexpr HexDiagonal() : value_(_enum(0)) { }
    constexpr HexDiagonal(_enum v) : value_(v) { }

    static constexpr _enum NORTH = _enum::NORTH;
    static constexpr _enum NORTH_EAST = _enum::NORTH_EAST;
    static constexpr _enum SOUTH_EAST = _enum::SOUTH_EAST;
    static constexpr _enum SOUTH = _enum::SOUTH;
    static constexpr _enum SOUTH_WEST = _enum::SOUTH_WEST;
    static constexpr _enum NORTH_WEST = _enum::NORTH_WEST;

    static constexpr std::array<_enum, 6> _values = {{
        NORTH, NORTH_EAST, SOUTH_EAST, SOUTH, SOUTH_WEST, NORTH_WEST, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(HexDiagonal v) { return static_cast<uint8_t>(v.value_) <= 5; }
    static constexpr bool _is_valid(uint8_t v) { return v <= 5; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const HexDiagonal::_enum v) {
        switch (v) {
            case HexDiagonal::NORTH: return "NORTH";
            case HexDiagonal::NORTH_EAST: return "NORTH_EAST";
            case HexDiagonal::SOUTH_EAST: return "SOUTH_EAST";
            case HexDiagonal::SOUTH: return "SOUTH";
            case HexDiagonal::SOUTH_WEST: return "SOUTH_WEST";
            case HexDiagonal::NORTH_WEST: return "NORTH_WEST";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, HexDiagonal::_enum> from_string<HexDiagonal>(const char* str) {
        constexpr std::array<std::pair<HexDiagonal::_enum,const char*>, 6> string_lookup_ = {{
            std::make_pair(HexDiagonal::NORTH, "NORTH"),
            std::make_pair(HexDiagonal::NORTH_EAST, "NORTH_EAST"),
            std::make_pair(HexDiagonal::SOUTH_EAST, "SOUTH_EAST"),
            std::make_pair(HexDiagonal::SOUTH, "SOUTH"),
            std::make_pair(HexDiagonal::SOUTH_WEST, "SOUTH_WEST"),
            std::make_pair(HexDiagonal::NORTH_WEST, "NORTH_WEST"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, HexDiagonal::_enum());
    }

// NegativeTest1 Definition
struct NegativeTest1 {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        A = -2,
        B = -1,
        C = 0,
        D = 1,
    };

    constexpr NegativeTest1() : value_(_enum(-2)) { }
    constexpr NegativeTest1(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;
    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;
    static constexpr _enum D = _enum::D;

    static constexpr std::array<_enum, 4> _values = {{
        A, B, C, D, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(NegativeTest1 v) { return (-2 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 1); }
    static constexpr bool _is_valid(int8_t v) { return (-2 <= v) && (v <= 1); }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest1::_enum v) {
        switch (v) {
            case NegativeTest1::A: return "A";
            case NegativeTest1::B: return "B";
            case NegativeTest1::C: return "C";
            case NegativeTest1::D: return "D";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, NegativeTest1::_enum> from_string<NegativeTest1>(const char* str) {
        constexpr std::array<std::pair<NegativeTest1::_enum,const char*>, 4> string_lookup_ = {{
            std::make_pair(NegativeTest1::A, "A"),
            std::make_pair(NegativeTest1::B, "B"),
            std::make_pair(NegativeTest1::C, "C"),
            std::make_pair(NegativeTest1::D, "D"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, NegativeTest1::_enum());
    }

// NegativeTest2 Definition
struct NegativeTest2 {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        A = -3,
        B = -2,
        C = -1,
        D = 0,
    };

    constexpr NegativeTest2() : value_(_enum(-3)) { }
    constexpr NegativeTest2(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;
    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;
    static constexpr _enum D = _enum::D;

    static constexpr std::array<_enum, 4> _values = {{
        A, B, C, D, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(NegativeTest2 v) { return (-3 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 0); }
    static constexpr bool _is_valid(int8_t v) { return (-3 <= v) && (v <= 0); }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest2::_enum v) {
        switch (v) {
            case NegativeTest2::A: return "A";
            case NegativeTest2::B: return "B";
            case NegativeTest2::C: return "C";
            case NegativeTest2::D: return "D";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, NegativeTest2::_enum> from_string<NegativeTest2>(const char* str) {
        constexpr std::array<std::pair<NegativeTest2::_enum,const char*>, 4> string_lookup_ = {{
            std::make_pair(NegativeTest2::A, "A"),
            std::make_pair(NegativeTest2::B, "B"),
            std::make_pair(NegativeTest2::C, "C"),
            std::make_pair(NegativeTest2::D, "D"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, NegativeTest2::_enum());
    }

// NegativeTest3 Definition
struct NegativeTest3 {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        A = -3,
        B = 4,
    };

    constexpr NegativeTest3() : value_(_enum(-3)) { }
    constexpr NegativeTest3(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;
    static constexpr _enum B = _enum::B;

    static constexpr std::array<_enum, 2> _values = {{
        A, B, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(NegativeTest3 v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int8_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest3::_enum v) {
        switch (v) {
            case NegativeTest3::A: return "A";
            case NegativeTest3::B: return "B";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, NegativeTest3::_enum> from_string<NegativeTest3>(const char* str) {
        constexpr std::array<std::pair<NegativeTest3::_enum,const char*>, 2> string_lookup_ = {{
            std::make_pair(NegativeTest3::A, "A"),
            std::make_pair(NegativeTest3::B, "B"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, NegativeTest3::_enum());
    }

// NegativeTest4 Definition
struct NegativeTest4 {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        A = -4,
        B = 3,
    };

    constexpr NegativeTest4() : value_(_enum(-4)) { }
    constexpr NegativeTest4(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;
    static constexpr _enum B = _enum::B;

    static constexpr std::array<_enum, 2> _values = {{
        A, B, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(NegativeTest4 v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(int8_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const NegativeTest4::_enum v) {
        switch (v) {
            case NegativeTest4::A: return "A";
            case NegativeTest4::B: return "B";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, NegativeTest4::_enum> from_string<NegativeTest4>(const char* str) {
        constexpr std::array<std::pair<NegativeTest4::_enum,const char*>, 2> string_lookup_ = {{
            std::make_pair(NegativeTest4::A, "A"),
            std::make_pair(NegativeTest4::B, "B"),
        }};
        for (std::size_t i = 0; i < string_lookup_.size(); i++) {
            if (enumbra::detail::streq(string_lookup_[i].second, str)) {
                return std::make_pair(true, string_lookup_[i].first);
            }
        }
        return std::make_pair(false, NegativeTest4::_enum());
    }

// EmptyTest1Unsigned Definition
struct EmptyTest1Unsigned {
    using _underlying_type = uint8_t;
    enum class _enum : uint8_t {
        A = 0,
    };

    constexpr EmptyTest1Unsigned() : value_(_enum(0)) { }
    constexpr EmptyTest1Unsigned(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;

    static constexpr std::array<_enum, 1> _values = {{
        A, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(EmptyTest1Unsigned v) { return static_cast<uint8_t>(v.value_) <= 0; }
    static constexpr bool _is_valid(uint8_t v) { return v <= 0; }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const EmptyTest1Unsigned::_enum v) {
        switch (v) {
            case EmptyTest1Unsigned::A: return "A";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, EmptyTest1Unsigned::_enum> from_string<EmptyTest1Unsigned>(const char* str) {
        constexpr std::array<std::pair<EmptyTest1Unsigned::_enum,const char*>, 1> string_lookup_ = {{
            std::make_pair(EmptyTest1Unsigned::A, "A"),
        }};
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, EmptyTest1Unsigned::_enum());
    }

// EmptyTest1Signed Definition
struct EmptyTest1Signed {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        A = 0,
    };

    constexpr EmptyTest1Signed() : value_(_enum(0)) { }
    constexpr EmptyTest1Signed(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;

    static constexpr std::array<_enum, 1> _values = {{
        A, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(EmptyTest1Signed v) { return (0 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 0); }
    static constexpr bool _is_valid(int8_t v) { return (0 <= v) && (v <= 0); }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const EmptyTest1Signed::_enum v) {
        switch (v) {
            case EmptyTest1Signed::A: return "A";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, EmptyTest1Signed::_enum> from_string<EmptyTest1Signed>(const char* str) {
        constexpr std::array<std::pair<EmptyTest1Signed::_enum,const char*>, 1> string_lookup_ = {{
            std::make_pair(EmptyTest1Signed::A, "A"),
        }};
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, EmptyTest1Signed::_enum());
    }

// SingleTest1Unsigned Definition
struct SingleTest1Unsigned {
    using _underlying_type = uint8_t;
    enum class _enum : uint8_t {
        A = 4,
    };

    constexpr SingleTest1Unsigned() : value_(_enum(4)) { }
    constexpr SingleTest1Unsigned(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;

    static constexpr std::array<_enum, 1> _values = {{
        A, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(SingleTest1Unsigned v) { return (4 <= static_cast<uint8_t>(v.value_)) && (static_cast<uint8_t>(v.value_) <= 4); }
    static constexpr bool _is_valid(uint8_t v) { return (4 <= v) && (v <= 4); }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const SingleTest1Unsigned::_enum v) {
        switch (v) {
            case SingleTest1Unsigned::A: return "A";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, SingleTest1Unsigned::_enum> from_string<SingleTest1Unsigned>(const char* str) {
        constexpr std::array<std::pair<SingleTest1Unsigned::_enum,const char*>, 1> string_lookup_ = {{
            std::make_pair(SingleTest1Unsigned::A, "A"),
        }};
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, SingleTest1Unsigned::_enum());
    }

// SingleTest1Signed Definition
struct SingleTest1Signed {
    using _underlying_type = int8_t;
    enum class _enum : int8_t {
        A = 4,
    };

    constexpr SingleTest1Signed() : value_(_enum(4)) { }
    constexpr SingleTest1Signed(_enum v) : value_(v) { }

    static constexpr _enum A = _enum::A;

    static constexpr std::array<_enum, 1> _values = {{
        A, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr operator _enum() const { return value_; }
    explicit operator bool() = delete;

    static constexpr bool _is_valid(SingleTest1Signed v) { return (4 <= static_cast<int8_t>(v.value_)) && (static_cast<int8_t>(v.value_) <= 4); }
    static constexpr bool _is_valid(int8_t v) { return (4 <= v) && (v <= 4); }


private:
    _enum value_;
};

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC const char* to_string(const SingleTest1Signed::_enum v) {
        switch (v) {
            case SingleTest1Signed::A: return "A";
        }
        return "";
    }

    template<>
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC std::pair<bool, SingleTest1Signed::_enum> from_string<SingleTest1Signed>(const char* str) {
        constexpr std::array<std::pair<SingleTest1Signed::_enum,const char*>, 1> string_lookup_ = {{
            std::make_pair(SingleTest1Signed::A, "A"),
        }};
        if (enumbra::detail::streq(string_lookup_[0].second, str)) {
            return std::make_pair(true, string_lookup_[0].first);
        }
        return std::make_pair(false, SingleTest1Signed::_enum());
    }

// test_flags Definition
struct test_flags {
    using _underlying_type = uint32_t;
    enum class _enum : uint32_t {
        B = 1,
        C = 2,
    };

    constexpr test_flags() : value_(_enum(0)) { }
    constexpr test_flags(_enum v) : value_(v) { }

    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;

    static constexpr std::array<_enum, 2> _values = {{
        B, C, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _zero() { value_ = static_cast<_enum>(0); }
    constexpr bool _test(_enum v) const { return (static_cast<uint32_t>(value_) & static_cast<uint32_t>(v)) == static_cast<uint32_t>(v); }
    constexpr void _set(_enum v) { value_ = static_cast<_enum>(static_cast<uint32_t>(value_) | static_cast<uint32_t>(v)); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _unset(_enum v) { value_ = static_cast<_enum>(static_cast<uint32_t>(value_) & (~static_cast<uint32_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _flip(_enum v) { value_ = static_cast<_enum>(static_cast<uint32_t>(value_) ^ static_cast<uint32_t>(v)); }
    constexpr bool _all() const { return static_cast<uint32_t>(value_) >= 0x3; }
    constexpr bool _any() const { return static_cast<uint32_t>(value_) > 0; }
    constexpr bool _none() const { return static_cast<uint32_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_single() const { uint32_t n = static_cast<uint32_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool _is_valid(test_flags v) { return static_cast<uint32_t>(v.value_) <= 3; }
    static constexpr bool _is_valid(uint32_t v) { return v <= 3; }

private:
    _enum value_;
};

// test_flags Operator Overloads
constexpr bool operator==(const test_flags& a, const test_flags& b) { return a._value() == b._value(); }
constexpr bool operator!=(const test_flags& a, const test_flags& b) { return a._value() != b._value(); }
constexpr test_flags::_enum operator~(const test_flags::_enum a) { return static_cast<test_flags::_enum>(~static_cast<uint32_t>(a)); }
constexpr test_flags::_enum operator|(const test_flags::_enum a, const test_flags::_enum b) { return static_cast<test_flags::_enum>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
constexpr test_flags::_enum operator&(const test_flags::_enum a, const test_flags::_enum b) { return static_cast<test_flags::_enum>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
constexpr test_flags::_enum operator^(const test_flags::_enum a, const test_flags::_enum b) { return static_cast<test_flags::_enum>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
constexpr test_flags operator~(const test_flags a) { return ~a._value(); }
constexpr test_flags operator|(const test_flags a, const test_flags b) { return a._value() | b._value(); }
constexpr test_flags operator&(const test_flags a, const test_flags b) { return a._value() & b._value(); }
constexpr test_flags operator^(const test_flags a, const test_flags b) { return a._value() ^ b._value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator|=(test_flags& a, const test_flags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator&=(test_flags& a, const test_flags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_flags& operator^=(test_flags& a, const test_flags b) { a = a ^ b; return a; }

// test_nodefault Definition
struct test_nodefault {
    using _underlying_type = uint16_t;
    enum class _enum : uint16_t {
        B = 1,
        C = 2,
    };

    constexpr test_nodefault() : value_(_enum(0)) { }
    constexpr test_nodefault(_enum v) : value_(v) { }

    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;

    static constexpr std::array<_enum, 2> _values = {{
        B, C, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _zero() { value_ = static_cast<_enum>(0); }
    constexpr bool _test(_enum v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    constexpr void _set(_enum v) { value_ = static_cast<_enum>(static_cast<uint32_t>(value_) | static_cast<uint32_t>(v)); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _unset(_enum v) { value_ = static_cast<_enum>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _flip(_enum v) { value_ = static_cast<_enum>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool _all() const { return static_cast<uint16_t>(value_) >= 0x3; }
    constexpr bool _any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool _none() const { return static_cast<uint16_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_single() const { uint16_t n = static_cast<uint16_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool _is_valid(test_nodefault v) { return static_cast<uint16_t>(v.value_) <= 3; }
    static constexpr bool _is_valid(uint16_t v) { return v <= 3; }

private:
    _enum value_;
};

// test_nodefault Operator Overloads
constexpr bool operator==(const test_nodefault& a, const test_nodefault& b) { return a._value() == b._value(); }
constexpr bool operator!=(const test_nodefault& a, const test_nodefault& b) { return a._value() != b._value(); }
constexpr test_nodefault::_enum operator~(const test_nodefault::_enum a) { return static_cast<test_nodefault::_enum>(~static_cast<uint16_t>(a)); }
constexpr test_nodefault::_enum operator|(const test_nodefault::_enum a, const test_nodefault::_enum b) { return static_cast<test_nodefault::_enum>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr test_nodefault::_enum operator&(const test_nodefault::_enum a, const test_nodefault::_enum b) { return static_cast<test_nodefault::_enum>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr test_nodefault::_enum operator^(const test_nodefault::_enum a, const test_nodefault::_enum b) { return static_cast<test_nodefault::_enum>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr test_nodefault operator~(const test_nodefault a) { return ~a._value(); }
constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b) { return a._value() | b._value(); }
constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b) { return a._value() & b._value(); }
constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b) { return a._value() ^ b._value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator|=(test_nodefault& a, const test_nodefault b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator&=(test_nodefault& a, const test_nodefault b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC test_nodefault& operator^=(test_nodefault& a, const test_nodefault b) { a = a ^ b; return a; }

// TestSparseFlags Definition
struct TestSparseFlags {
    using _underlying_type = uint16_t;
    enum class _enum : uint16_t {
        B = 1,
        C = 4,
        D = 16,
    };

    constexpr TestSparseFlags() : value_(_enum(0)) { }
    constexpr TestSparseFlags(_enum v) : value_(v) { }

    static constexpr _enum B = _enum::B;
    static constexpr _enum C = _enum::C;
    static constexpr _enum D = _enum::D;

    static constexpr std::array<_enum, 3> _values = {{
        B, C, D, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _zero() { value_ = static_cast<_enum>(0); }
    constexpr bool _test(_enum v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    constexpr void _set(_enum v) { value_ = static_cast<_enum>(static_cast<uint32_t>(value_) | static_cast<uint32_t>(v)); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _unset(_enum v) { value_ = static_cast<_enum>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _flip(_enum v) { value_ = static_cast<_enum>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool _all() const { return static_cast<uint16_t>(value_) >= 0x15; }
    constexpr bool _any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool _none() const { return static_cast<uint16_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_single() const { uint16_t n = static_cast<uint16_t>(value_); return n && !(n & (n - 1)); }

    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(TestSparseFlags v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == v._value()) return true; } return false; }
    static ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_valid(uint16_t v) { for(std::size_t i = 0; i < _values.size(); i++) { auto& val = _values[i]; if(val == _enum(v)) return true; } return false; }

private:
    _enum value_;
};

// TestSparseFlags Operator Overloads
constexpr bool operator==(const TestSparseFlags& a, const TestSparseFlags& b) { return a._value() == b._value(); }
constexpr bool operator!=(const TestSparseFlags& a, const TestSparseFlags& b) { return a._value() != b._value(); }
constexpr TestSparseFlags::_enum operator~(const TestSparseFlags::_enum a) { return static_cast<TestSparseFlags::_enum>(~static_cast<uint16_t>(a)); }
constexpr TestSparseFlags::_enum operator|(const TestSparseFlags::_enum a, const TestSparseFlags::_enum b) { return static_cast<TestSparseFlags::_enum>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr TestSparseFlags::_enum operator&(const TestSparseFlags::_enum a, const TestSparseFlags::_enum b) { return static_cast<TestSparseFlags::_enum>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr TestSparseFlags::_enum operator^(const TestSparseFlags::_enum a, const TestSparseFlags::_enum b) { return static_cast<TestSparseFlags::_enum>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr TestSparseFlags operator~(const TestSparseFlags a) { return ~a._value(); }
constexpr TestSparseFlags operator|(const TestSparseFlags a, const TestSparseFlags b) { return a._value() | b._value(); }
constexpr TestSparseFlags operator&(const TestSparseFlags a, const TestSparseFlags b) { return a._value() & b._value(); }
constexpr TestSparseFlags operator^(const TestSparseFlags a, const TestSparseFlags b) { return a._value() ^ b._value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator|=(TestSparseFlags& a, const TestSparseFlags b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator&=(TestSparseFlags& a, const TestSparseFlags b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSparseFlags& operator^=(TestSparseFlags& a, const TestSparseFlags b) { a = a ^ b; return a; }

// TestSingleFlag Definition
struct TestSingleFlag {
    using _underlying_type = uint16_t;
    enum class _enum : uint16_t {
        C = 4,
    };

    constexpr TestSingleFlag() : value_(_enum(0)) { }
    constexpr TestSingleFlag(_enum v) : value_(v) { }

    static constexpr _enum C = _enum::C;

    static constexpr std::array<_enum, 1> _values = {{
        C, 
    }};

    constexpr _enum _value() const { return value_; }
    constexpr explicit operator bool() const = delete;

    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _zero() { value_ = static_cast<_enum>(0); }
    constexpr bool _test(_enum v) const { return (static_cast<uint16_t>(value_) & static_cast<uint16_t>(v)) == static_cast<uint16_t>(v); }
    constexpr void _set(_enum v) { value_ = static_cast<_enum>(static_cast<uint32_t>(value_) | static_cast<uint32_t>(v)); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _unset(_enum v) { value_ = static_cast<_enum>(static_cast<uint16_t>(value_) & (~static_cast<uint16_t>(v))); }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC void _flip(_enum v) { value_ = static_cast<_enum>(static_cast<uint16_t>(value_) ^ static_cast<uint16_t>(v)); }
    constexpr bool _all() const { return static_cast<uint16_t>(value_) >= 0x4; }
    constexpr bool _any() const { return static_cast<uint16_t>(value_) > 0; }
    constexpr bool _none() const { return static_cast<uint16_t>(value_) == 0; }
    ENUMBRA_CONSTEXPR_NONCONSTFUNC bool _is_single() const { uint16_t n = static_cast<uint16_t>(value_); return n && !(n & (n - 1)); }

    static constexpr bool _is_valid(TestSingleFlag v) { return static_cast<uint16_t>(v.value_) <= 4; }
    static constexpr bool _is_valid(uint16_t v) { return v <= 4; }

private:
    _enum value_;
};

// TestSingleFlag Operator Overloads
constexpr bool operator==(const TestSingleFlag& a, const TestSingleFlag& b) { return a._value() == b._value(); }
constexpr bool operator!=(const TestSingleFlag& a, const TestSingleFlag& b) { return a._value() != b._value(); }
constexpr TestSingleFlag::_enum operator~(const TestSingleFlag::_enum a) { return static_cast<TestSingleFlag::_enum>(~static_cast<uint16_t>(a)); }
constexpr TestSingleFlag::_enum operator|(const TestSingleFlag::_enum a, const TestSingleFlag::_enum b) { return static_cast<TestSingleFlag::_enum>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr TestSingleFlag::_enum operator&(const TestSingleFlag::_enum a, const TestSingleFlag::_enum b) { return static_cast<TestSingleFlag::_enum>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr TestSingleFlag::_enum operator^(const TestSingleFlag::_enum a, const TestSingleFlag::_enum b) { return static_cast<TestSingleFlag::_enum>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr TestSingleFlag operator~(const TestSingleFlag a) { return ~a._value(); }
constexpr TestSingleFlag operator|(const TestSingleFlag a, const TestSingleFlag b) { return a._value() | b._value(); }
constexpr TestSingleFlag operator&(const TestSingleFlag a, const TestSingleFlag b) { return a._value() & b._value(); }
constexpr TestSingleFlag operator^(const TestSingleFlag a, const TestSingleFlag b) { return a._value() ^ b._value(); }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator|=(TestSingleFlag& a, const TestSingleFlag b) { a = a | b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator&=(TestSingleFlag& a, const TestSingleFlag b) { a = a & b; return a; }
ENUMBRA_CONSTEXPR_NONCONSTFUNC TestSingleFlag& operator^=(TestSingleFlag& a, const TestSingleFlag b) { a = a ^ b; return a; }

} // namespace enums

// Template Specializations Begin
template<> struct enumbra::detail::base_helper<enums::test_string_parse::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::test_string_parse; };
template<> struct enumbra::detail::base_helper<enums::test_string_parse> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::test_string_parse; };
template<> struct enumbra::detail::base_helper<enums::Unsigned64Test::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::Unsigned64Test; };
template<> struct enumbra::detail::base_helper<enums::Unsigned64Test> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::Unsigned64Test; };
template<> struct enumbra::detail::base_helper<enums::Signed64Test::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::Signed64Test; };
template<> struct enumbra::detail::base_helper<enums::Signed64Test> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::Signed64Test; };
template<> struct enumbra::detail::base_helper<enums::Signed32Test::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::Signed32Test; };
template<> struct enumbra::detail::base_helper<enums::Signed32Test> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::Signed32Test; };
template<> struct enumbra::detail::base_helper<enums::Signed16Test::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::Signed16Test; };
template<> struct enumbra::detail::base_helper<enums::Signed16Test> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::Signed16Test; };
template<> struct enumbra::detail::base_helper<enums::Signed8Test::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::Signed8Test; };
template<> struct enumbra::detail::base_helper<enums::Signed8Test> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::Signed8Test; };
template<> struct enumbra::detail::base_helper<enums::test_value::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::test_value; };
template<> struct enumbra::detail::base_helper<enums::test_value> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::test_value; };
template<> struct enumbra::detail::base_helper<enums::HexDiagonal::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::HexDiagonal; };
template<> struct enumbra::detail::base_helper<enums::HexDiagonal> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::HexDiagonal; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest1::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::NegativeTest1; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest1> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::NegativeTest1; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest2::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::NegativeTest2; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest2> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::NegativeTest2; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest3::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::NegativeTest3; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest3> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::NegativeTest3; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest4::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::NegativeTest4; };
template<> struct enumbra::detail::base_helper<enums::NegativeTest4> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::NegativeTest4; };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Unsigned::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::EmptyTest1Unsigned; };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Unsigned> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::EmptyTest1Unsigned; };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Signed::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::EmptyTest1Signed; };
template<> struct enumbra::detail::base_helper<enums::EmptyTest1Signed> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::EmptyTest1Signed; };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Unsigned::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::SingleTest1Unsigned; };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Unsigned> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::SingleTest1Unsigned; };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Signed::_enum> : enumbra::detail::type_info<true, true, true, false> { using base_type = enums::SingleTest1Signed; };
template<> struct enumbra::detail::base_helper<enums::SingleTest1Signed> : enumbra::detail::type_info<true, false, true, false> { using base_type = enums::SingleTest1Signed; };
template<> struct enumbra::detail::base_helper<enums::test_flags::_enum> : enumbra::detail::type_info<true, true, false, true> { using base_type = enums::test_flags; };
template<> struct enumbra::detail::base_helper<enums::test_flags> : enumbra::detail::type_info<true, false, false, true> { using base_type = enums::test_flags; };
template<> struct enumbra::detail::base_helper<enums::test_nodefault::_enum> : enumbra::detail::type_info<true, true, false, true> { using base_type = enums::test_nodefault; };
template<> struct enumbra::detail::base_helper<enums::test_nodefault> : enumbra::detail::type_info<true, false, false, true> { using base_type = enums::test_nodefault; };
template<> struct enumbra::detail::base_helper<enums::TestSparseFlags::_enum> : enumbra::detail::type_info<true, true, false, true> { using base_type = enums::TestSparseFlags; };
template<> struct enumbra::detail::base_helper<enums::TestSparseFlags> : enumbra::detail::type_info<true, false, false, true> { using base_type = enums::TestSparseFlags; };
template<> struct enumbra::detail::base_helper<enums::TestSingleFlag::_enum> : enumbra::detail::type_info<true, true, false, true> { using base_type = enums::TestSingleFlag; };
template<> struct enumbra::detail::base_helper<enums::TestSingleFlag> : enumbra::detail::type_info<true, false, false, true> { using base_type = enums::TestSingleFlag; };
template<> struct enumbra::detail::value_enum_helper<enums::test_string_parse::_enum> : enumbra::detail::value_enum_info<int64_t, -1, 9223372036854775807, int, 5, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_string_parse> : enumbra::detail::value_enum_info<int64_t, -1, 9223372036854775807, int, 5, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Unsigned64Test::_enum> : enumbra::detail::value_enum_info<uint64_t, 0, 0xFFFFFFFFFFFFFFFF, int, 4, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Unsigned64Test> : enumbra::detail::value_enum_info<uint64_t, 0, 0xFFFFFFFFFFFFFFFF, int, 4, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed64Test::_enum> : enumbra::detail::value_enum_info<int64_t, (-9223372036854775807 - 1), 9223372036854775807, int, 3, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed64Test> : enumbra::detail::value_enum_info<int64_t, (-9223372036854775807 - 1), 9223372036854775807, int, 3, false, 64, 64> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed32Test::_enum> : enumbra::detail::value_enum_info<int32_t, (-2147483647 - 1), 2147483647, int, 3, false, 32, 32> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed32Test> : enumbra::detail::value_enum_info<int32_t, (-2147483647 - 1), 2147483647, int, 3, false, 32, 32> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed16Test::_enum> : enumbra::detail::value_enum_info<int16_t, (-32767 - 1), 32767, int, 3, false, 16, 16> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed16Test> : enumbra::detail::value_enum_info<int16_t, (-32767 - 1), 32767, int, 3, false, 16, 16> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed8Test::_enum> : enumbra::detail::value_enum_info<int8_t, (-127 - 1), 127, int, 3, false, 8, 8> { };
template<> struct enumbra::detail::value_enum_helper<enums::Signed8Test> : enumbra::detail::value_enum_info<int8_t, (-127 - 1), 127, int, 3, false, 8, 8> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_value::_enum> : enumbra::detail::value_enum_info<int32_t, 0, 2, int, 3, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::test_value> : enumbra::detail::value_enum_info<int32_t, 0, 2, int, 3, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::HexDiagonal::_enum> : enumbra::detail::value_enum_info<uint8_t, 0, 5, int, 6, true, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::HexDiagonal> : enumbra::detail::value_enum_info<uint8_t, 0, 5, int, 6, true, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest1::_enum> : enumbra::detail::value_enum_info<int8_t, -2, 1, int, 4, true, 2, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest1> : enumbra::detail::value_enum_info<int8_t, -2, 1, int, 4, true, 2, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest2::_enum> : enumbra::detail::value_enum_info<int8_t, -3, 0, int, 4, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest2> : enumbra::detail::value_enum_info<int8_t, -3, 0, int, 4, true, 3, 2> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest3::_enum> : enumbra::detail::value_enum_info<int8_t, -3, 4, int, 2, false, 4, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest3> : enumbra::detail::value_enum_info<int8_t, -3, 4, int, 2, false, 4, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest4::_enum> : enumbra::detail::value_enum_info<int8_t, -4, 3, int, 2, false, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::NegativeTest4> : enumbra::detail::value_enum_info<int8_t, -4, 3, int, 2, false, 3, 3> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Unsigned::_enum> : enumbra::detail::value_enum_info<uint8_t, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Unsigned> : enumbra::detail::value_enum_info<uint8_t, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Signed::_enum> : enumbra::detail::value_enum_info<int8_t, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::EmptyTest1Signed> : enumbra::detail::value_enum_info<int8_t, 0, 0, int, 1, true, 1, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Unsigned::_enum> : enumbra::detail::value_enum_info<uint8_t, 4, 4, int, 1, true, 3, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Unsigned> : enumbra::detail::value_enum_info<uint8_t, 4, 4, int, 1, true, 3, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Signed::_enum> : enumbra::detail::value_enum_info<int8_t, 4, 4, int, 1, true, 4, 0> { };
template<> struct enumbra::detail::value_enum_helper<enums::SingleTest1Signed> : enumbra::detail::value_enum_info<int8_t, 4, 4, int, 1, true, 4, 0> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_flags::_enum> : enumbra::detail::flags_enum_info<uint32_t, 0, 3, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_flags> : enumbra::detail::flags_enum_info<uint32_t, 0, 3, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_nodefault::_enum> : enumbra::detail::flags_enum_info<uint16_t, 0, 3, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::test_nodefault> : enumbra::detail::flags_enum_info<uint16_t, 0, 3, int, 2, true, 2, 2> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSparseFlags::_enum> : enumbra::detail::flags_enum_info<uint16_t, 0, 21, int, 3, false, 5, 5> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSparseFlags> : enumbra::detail::flags_enum_info<uint16_t, 0, 21, int, 3, false, 5, 5> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSingleFlag::_enum> : enumbra::detail::flags_enum_info<uint16_t, 0, 4, int, 1, true, 3, 3> { };
template<> struct enumbra::detail::flags_enum_helper<enums::TestSingleFlag> : enumbra::detail::flags_enum_info<uint16_t, 0, 4, int, 1, true, 3, 3> { };
// Template Specializations End
