// The following file was generated by ChatGPT 4o
// The output is "good enough", but not optimized and doesn't cover every edge case.

#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <stack>

struct NamespaceInfo {
    std::string name;      // The fully qualified name of the namespace
    size_t startPos;       // The start position of the namespace in the original string
    size_t endPos;         // The end position of the namespace in the original string
};

std::vector<NamespaceInfo> extractNamespaces(const std::string& code) {
    std::vector<NamespaceInfo> namespaces;
    std::stack<std::string> namespaceStack; // Stack to manage fully qualified namespace names

    size_t length = code.length();
    for (size_t i = 0; i < length; ++i) {
        // Check for 'namespace' keyword
        if (code.substr(i, 9) == "namespace") {
            size_t start = i; // Start position of the namespace declaration
            i += 9; // Move past the "namespace" keyword

            // Skip whitespace
            while (i < length && (code[i] == ' ' || code[i] == '\t')) {
                ++i;
            }

            // Capture the namespace name
            size_t nameStart = i;
            while (i < length && (isalnum(code[i]) || code[i] == '_' || code[i] == ':')) {
                ++i;
            }
            std::string nsName = code.substr(nameStart, i - nameStart);

            // Fully qualified namespace
            if (!namespaceStack.empty()) {
                nsName = namespaceStack.top() + "::" + nsName; // Concatenate with the parent namespace
            }

            // Skip whitespace before '{'
            while (i < length && (code[i] == ' ' || code[i] == '\t')) {
                ++i;
            }

            if (i < length && code[i] == '{') {
                // Namespace found, store the information
                namespaces.push_back({ nsName, start, 0 }); // Initialize endPos to 0
                namespaceStack.push(nsName); // Push the fully qualified namespace name onto the stack
            }
        }

        // Check for closing brace '}' to manage nested namespaces
        if (code[i] == '}') {
            if (!namespaceStack.empty()) {
                size_t index = namespaces.size() - 1; // Update the last namespace
                namespaces[index].endPos = i; // Update the last namespace's end position
                namespaceStack.pop(); // Pop the last namespace from the stack
            }
        }
    }

    return namespaces;
}