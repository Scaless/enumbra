// THIS CODE WAS GENERATED BY A TOOL (haha)
// Direct your feedback and monetary donations to: https://github.com/Scaless/enumbra
// It is highly recommended to not make manual edits to this file, as they will be overwritten
// when the file is re-generated. But do what you want, I'm a tool not a cop.
// Generated by enumbra v0.0.3 on Tue Dec 28 14:21:55 2021

// Hey! You don't have any preamble_text set. If you have a license you want to apply to your
// generated code, you should edit your enumbra_config.toml file!

#pragma once

#include <array>
#include <cstdint>

#define ENUMBRA_PACK(Enum, Name) Enum::Value Name : Enum##::bits_required_storage();

namespace enumbra {

// test_value Definition
struct test_value {
    using ValueType = int32_t;
    enum class Value : int32_t {
        A = 0,
        B = 1,
        C = 2,
    };

    constexpr test_value() : value(Value(0)) { };
    constexpr test_value(Value v) : value(v) { }

    constexpr static std::array<Value, 3> Values = {
        Value::A,
        Value::B,
        Value::C,
    };

    constexpr static Value A = Value::A;
    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr operator Value() const { return value; }
    explicit operator bool() = delete;

    constexpr void reset() { value = test_value(); }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr int32_t min() { return 0; }
    static constexpr int32_t max() { return 2; }
    static constexpr int count() { return 3; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_value from_underlying_unsafe(int32_t v) { return test_value(static_cast<Value>(v)); }
    static constexpr int32_t bits_required_storage() { return 2; }
    static constexpr int32_t bits_required_transmission() { return 2; }
    static constexpr bool contains(test_value v) { return (0 <= static_cast<int32_t>(v.value)) && (static_cast<int32_t>(v.value) <= 2); }
    static constexpr bool contains(int32_t v) { return (0 <= v) && (v <= 2); }

private:
    Value value;
};

// HexDiagonal Definition
struct HexDiagonal {
    using ValueType = uint8_t;
    enum class Value : uint8_t {
        NORTH = 0,
        NORTH_EAST = 1,
        SOUTH_EAST = 2,
        SOUTH = 3,
        SOUTH_WEST = 4,
        NORTH_WEST = 5,
    };

    constexpr HexDiagonal() : value(Value(0)) { };
    constexpr HexDiagonal(Value v) : value(v) { }

    constexpr static std::array<Value, 6> Values = {
        Value::NORTH,
        Value::NORTH_EAST,
        Value::SOUTH_EAST,
        Value::SOUTH,
        Value::SOUTH_WEST,
        Value::NORTH_WEST,
    };

    constexpr static Value NORTH = Value::NORTH;
    constexpr static Value NORTH_EAST = Value::NORTH_EAST;
    constexpr static Value SOUTH_EAST = Value::SOUTH_EAST;
    constexpr static Value SOUTH = Value::SOUTH;
    constexpr static Value SOUTH_WEST = Value::SOUTH_WEST;
    constexpr static Value NORTH_WEST = Value::NORTH_WEST;

    constexpr operator Value() const { return value; }
    explicit operator bool() = delete;

    constexpr void reset() { value = HexDiagonal(); }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint8_t min() { return 0; }
    static constexpr uint8_t max() { return 5; }
    static constexpr int count() { return 6; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr HexDiagonal from_underlying_unsafe(uint8_t v) { return HexDiagonal(static_cast<Value>(v)); }
    static constexpr uint8_t bits_required_storage() { return 3; }
    static constexpr uint8_t bits_required_transmission() { return 3; }
    static constexpr bool contains(HexDiagonal v) { return (0 <= static_cast<uint8_t>(v.value)) && (static_cast<uint8_t>(v.value) <= 5); }
    static constexpr bool contains(uint8_t v) { return (0 <= v) && (v <= 5); }

private:
    Value value;
};

// test_flags Definition
struct test_flags {
    using ValueType = uint32_t;
    enum class Value : uint32_t {
        B = 1,
        C = 2,
    };

    constexpr test_flags() : value(Value(0)) { };
    constexpr test_flags(Value v) : value(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::B,
        Value::C,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr operator Value() const { return value; }
    explicit operator bool() = delete;

    constexpr void reset() { value = test_flags(); }
    constexpr bool is_set(Value v) const { return (*this & v) == v; }
    constexpr bool all() const { return static_cast<uint32_t>(value) == 3; }
    constexpr bool any() const { return static_cast<uint32_t>(value) > 0; }
    constexpr bool none() const { return static_cast<uint32_t>(value) == 0; }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint32_t min() { return 0; }
    static constexpr uint32_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_flags from_underlying_unsafe(uint32_t v) { return test_flags(static_cast<Value>(v)); }
    static constexpr uint32_t bits_required_storage() { return 2; }
    static constexpr uint32_t bits_required_transmission() { return 2; }
    static constexpr bool contains(test_flags v) { return (0 <= static_cast<uint32_t>(v.value)) && (static_cast<uint32_t>(v.value) <= 3); }
    static constexpr bool contains(uint32_t v) { return (0 <= v) && (v <= 3); }

    friend constexpr test_flags operator~(const test_flags a);
    friend constexpr test_flags operator|(const test_flags a, const test_flags b);
    friend constexpr test_flags operator&(const test_flags a, const test_flags b);
    friend constexpr test_flags operator^(const test_flags a, const test_flags b);
    friend constexpr test_flags operator|(const test_flags a, const test_flags::Value b);
    friend constexpr test_flags operator&(const test_flags a, const test_flags::Value b);
    friend constexpr test_flags operator^(const test_flags a, const test_flags::Value b);
    friend constexpr test_flags operator|(const test_flags::Value a, const test_flags b);
    friend constexpr test_flags operator&(const test_flags::Value a, const test_flags b);
    friend constexpr test_flags operator^(const test_flags::Value a, const test_flags b);
private:
    Value value;
};

// test_flags Operator Overloads
constexpr test_flags::Value operator~(const test_flags::Value a) { return static_cast<test_flags::Value>(~static_cast<uint32_t>(a)); }
constexpr test_flags::Value operator|(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator&(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b)); }
constexpr test_flags::Value operator^(const test_flags::Value a, const test_flags::Value b) { return static_cast<test_flags::Value>(static_cast<uint32_t>(a) ^ static_cast<uint32_t>(b)); }
constexpr test_flags operator~ (const test_flags a) { return static_cast<test_flags>(static_cast<test_flags::Value>(~static_cast<uint32_t>(a.value))); }
constexpr test_flags operator| (const test_flags a, const test_flags b) { return a.value | b.value; }
constexpr test_flags operator& (const test_flags a, const test_flags b) { return a.value & b.value; }
constexpr test_flags operator^ (const test_flags a, const test_flags b) { return a.value ^ b.value; }
constexpr test_flags operator| (const test_flags a, const test_flags::Value b) { return a.value | b; }
constexpr test_flags operator& (const test_flags a, const test_flags::Value b) { return a.value & b; }
constexpr test_flags operator^ (const test_flags a, const test_flags::Value b) { return a.value ^ b; }
constexpr test_flags operator| (const test_flags::Value a, const test_flags b) { return a | b.value; }
constexpr test_flags operator& (const test_flags::Value a, const test_flags b) { return a & b.value; }
constexpr test_flags operator^ (const test_flags::Value a, const test_flags b) { return a ^ b.value; }
constexpr test_flags& operator|= (test_flags & a, const test_flags b) { a = a | b; return a; }
constexpr test_flags& operator&= (test_flags & a, const test_flags b) { a = a & b; return a; }
constexpr test_flags& operator^= (test_flags & a, const test_flags b) { a = a ^ b; return a; }

// test_nodefault Definition
struct test_nodefault {
    using ValueType = uint16_t;
    enum class Value : uint16_t {
        B = 1,
        C = 2,
    };

    constexpr test_nodefault() : value(Value(0)) { };
    constexpr test_nodefault(Value v) : value(v) { }

    constexpr static std::array<Value, 2> Values = {
        Value::B,
        Value::C,
    };

    constexpr static Value B = Value::B;
    constexpr static Value C = Value::C;

    constexpr operator Value() const { return value; }
    explicit operator bool() = delete;

    constexpr void reset() { value = test_nodefault(); }
    constexpr bool is_set(Value v) const { return (*this & v) == v; }
    constexpr bool all() const { return static_cast<uint16_t>(value) == 3; }
    constexpr bool any() const { return static_cast<uint16_t>(value) > 0; }
    constexpr bool none() const { return static_cast<uint16_t>(value) == 0; }

    static constexpr bool is_enumbra_value_enum() { return false; }
    static constexpr bool is_enumbra_flags_enum() { return true; }
    static constexpr uint16_t min() { return 0; }
    static constexpr uint16_t max() { return 0x3; }
    static constexpr int count() { return 2; }
    static constexpr bool is_contiguous() { return true; }
    static constexpr test_nodefault from_underlying_unsafe(uint16_t v) { return test_nodefault(static_cast<Value>(v)); }
    static constexpr uint16_t bits_required_storage() { return 2; }
    static constexpr uint16_t bits_required_transmission() { return 2; }
    static constexpr bool contains(test_nodefault v) { return (0 <= static_cast<uint16_t>(v.value)) && (static_cast<uint16_t>(v.value) <= 3); }
    static constexpr bool contains(uint16_t v) { return (0 <= v) && (v <= 3); }

    friend constexpr test_nodefault operator~(const test_nodefault a);
    friend constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault b);
    friend constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault b);
    friend constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault b);
    friend constexpr test_nodefault operator|(const test_nodefault a, const test_nodefault::Value b);
    friend constexpr test_nodefault operator&(const test_nodefault a, const test_nodefault::Value b);
    friend constexpr test_nodefault operator^(const test_nodefault a, const test_nodefault::Value b);
    friend constexpr test_nodefault operator|(const test_nodefault::Value a, const test_nodefault b);
    friend constexpr test_nodefault operator&(const test_nodefault::Value a, const test_nodefault b);
    friend constexpr test_nodefault operator^(const test_nodefault::Value a, const test_nodefault b);
private:
    Value value;
};

// test_nodefault Operator Overloads
constexpr test_nodefault::Value operator~(const test_nodefault::Value a) { return static_cast<test_nodefault::Value>(~static_cast<uint16_t>(a)); }
constexpr test_nodefault::Value operator|(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) | static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator&(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) & static_cast<uint16_t>(b)); }
constexpr test_nodefault::Value operator^(const test_nodefault::Value a, const test_nodefault::Value b) { return static_cast<test_nodefault::Value>(static_cast<uint16_t>(a) ^ static_cast<uint16_t>(b)); }
constexpr test_nodefault operator~ (const test_nodefault a) { return static_cast<test_nodefault>(static_cast<test_nodefault::Value>(~static_cast<uint16_t>(a.value))); }
constexpr test_nodefault operator| (const test_nodefault a, const test_nodefault b) { return a.value | b.value; }
constexpr test_nodefault operator& (const test_nodefault a, const test_nodefault b) { return a.value & b.value; }
constexpr test_nodefault operator^ (const test_nodefault a, const test_nodefault b) { return a.value ^ b.value; }
constexpr test_nodefault operator| (const test_nodefault a, const test_nodefault::Value b) { return a.value | b; }
constexpr test_nodefault operator& (const test_nodefault a, const test_nodefault::Value b) { return a.value & b; }
constexpr test_nodefault operator^ (const test_nodefault a, const test_nodefault::Value b) { return a.value ^ b; }
constexpr test_nodefault operator| (const test_nodefault::Value a, const test_nodefault b) { return a | b.value; }
constexpr test_nodefault operator& (const test_nodefault::Value a, const test_nodefault b) { return a & b.value; }
constexpr test_nodefault operator^ (const test_nodefault::Value a, const test_nodefault b) { return a ^ b.value; }
constexpr test_nodefault& operator|= (test_nodefault & a, const test_nodefault b) { a = a | b; return a; }
constexpr test_nodefault& operator&= (test_nodefault & a, const test_nodefault b) { a = a & b; return a; }
constexpr test_nodefault& operator^= (test_nodefault & a, const test_nodefault b) { a = a ^ b; return a; }


} // namespace enumbra
