#include "cpp_generator.h"
#include <sstream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <set>

using namespace enumbra;
using namespace enumbra::cpp;

std::string to_upper(const std::string& str)
{
	std::string strcopy = str;
	std::transform(strcopy.begin(), strcopy.end(), strcopy.begin(), ::toupper);
	return strcopy;
}

const enum_entry& get_enum_entry_value(const ValueEnumDefaultValueStyle& style, const enum_definition& definition)
{
	switch (style)
	{
	case ValueEnumDefaultValueStyle::Min:
	{
		auto& m = std::min_element(definition.values.begin(), definition.values.end(),
			[](const enum_entry& lhs, const enum_entry& rhs) { return lhs.value < rhs.value; });
		if (m != definition.values.end())
		{
			return *m;
		}
		else
		{
			throw std::runtime_error("get_value_enum_default_value_style_string: ValueEnumDefaultValueStyle::Min failed somehow.");
		}
		break;
	}
	case ValueEnumDefaultValueStyle::Max:
	{
		auto& m = std::max_element(definition.values.begin(), definition.values.end(),
			[](const enum_entry& lhs, const enum_entry& rhs) { return lhs.value < rhs.value; });
		if (m != definition.values.end())
		{
			return *m;
		}
		else
		{
			throw std::runtime_error("get_value_enum_default_value_style_string: ValueEnumDefaultValueStyle::Max failed somehow.");
		}
		break;
	}
	case ValueEnumDefaultValueStyle::First:
	{
		return definition.values.front();
	}
	case ValueEnumDefaultValueStyle::Last:
	{
		return definition.values.back();
	}
	default:
		throw std::runtime_error("value_enum_default_value_style: Invalid ValueEnumDefaultValueStyle");
	}
}

// Log2 of unsigned int
constexpr uint64_t Log2Unsigned(uint64_t x)
{
	if (x == 0)
	{
		throw std::runtime_error("Log2Unsigned: Input value of 0 is not valid!");
	}

	int targetlevel = 0;
	while (x >>= 1)
		++targetlevel;
	return targetlevel;
}

std::string cpp_generator::generate_cpp_output(const enumbra_config& cfg, const enumbra::enum_meta_config& enum_meta)
{
	// Preconditions
	//enum_meta.flag_enum_definitions

	auto& cpp = cfg.cpp_config;

	std::stringstream output;

	// Setting up re-usable tokens
	LF = (cpp.line_ending_style == cpp::LineEndingStyle::LF) ? "\n" : "\r\n";
	TAB = cpp.output_tab_characters;
	const std::string def_macro = "ENUMBRA_" + to_upper(enum_meta.block_name) + "_H";

	// Fixed enumbra pre-preamble
	std::time_t time_point = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
	char time_buf[255];
	ctime_s(time_buf, 255, &time_point);
	output << "// This file was generated by enumbra on: " << time_buf;
	output << "// The enumbra project is hosted at: https://github.com/Scaless/enumbra" << LF << LF;

	// Custom preamble
	for (const auto& line : cpp.preamble_text) {
		output << line << LF;
	}

	// INCLUDE GUARD
	switch (cpp.include_guard_style)
	{
	case enumbra::cpp::IncludeGuardStyle::None:
		break;
	case enumbra::cpp::IncludeGuardStyle::PragmaOnce:
		output << "#pragma once" << LF << LF;
		break;
	case enumbra::cpp::IncludeGuardStyle::CStyle:
	{
		output << "#ifndef " << def_macro << LF << "#define " << def_macro << LF << LF;
		break;
	}
	default:
		throw std::runtime_error("include_guard_wrap: Invalid IncludeGuardStyle");
	}

	// INCLUDES
	for (const auto& inc : cpp.additional_includes) {
		output << "#include " << inc << LF;
	}
	if (cpp.string_table_layout != StringTableLayout::None) {
		if (cpp.string_table_type == StringTableType::ConstexprStringView || cpp.string_table_type == StringTableType::ConstexprWStringView)
		{
			output << "#include <string_view>" << LF;
		}
	}
	output << LF;

	// START CONFIG NAMESPACE
	for (const auto& ns : cpp.output_namespace) {
		output << "namespace " << ns << " {" << LF;
	}
	output << LF;

	// VALUE ENUM DEFINITIONS
	for (auto& e : enum_meta.value_enum_definitions) {

		// Precondition checks
		// 1. Enum value names must be unique
		std::set<std::string> seen_names;
		for (auto& v : e.values)
		{
			auto& seen = seen_names.find(v.name);
			if (seen != seen_names.end())
			{
				throw std::runtime_error("ENUM DEFINITIONS Precondition Check 1: Enum Value Name is not unique (name = " + *seen + ")");
			}
			seen_names.insert(v.name);
		}
		seen_names.clear();
		// 2. Enum must have at least 1 value
		if (e.values.size() == 0)
		{
			throw std::runtime_error("ENUM DEFINITIONS Precondition Check 2: Enum does not contain any values (name = " + e.name + ")");
		}

		// Get references and metadata for relevant enum values that we will need
		const enum_entry& default_entry = get_enum_entry_value(enum_meta.value_enum_default_value_style, e);
		const enum_entry& min_entry = get_enum_entry_value(ValueEnumDefaultValueStyle::Min, e);
		const enum_entry& max_entry = get_enum_entry_value(ValueEnumDefaultValueStyle::Max, e);
		const size_t entry_count = e.values.size();
		const size_t bits_required = Log2Unsigned(max_entry.value) + 1;

		// Determine if all values are unique, or if some enum value names overlap.
		// TODO: Enforce if flag is set
		std::set<int64_t> unique_values;
		for (auto& v : e.values) { unique_values.insert(v.value); }
		const size_t unique_entry_count = unique_values.size();

		// Determine if range is contiguous
		// Enables some minor optimizations for range-checking values if true
		// TODO: Enforce if flag is set
		bool is_contiguous = true;
		int64_t value = *unique_values.begin();
		bool skip_first = true;
		for (auto& u : unique_values)
		{
			if (skip_first) {
				skip_first = false;
				continue;
			}
			if (u != (value + 1))
			{
				is_contiguous = false;
				break;
			}
			value++;
		}

		// BEGIN CLASS GENERATION
		output << "class " << e.name << " {" << LF;
		output << "public:" << LF;
		output << TAB << "using value_type = " << cpp.get_size_type_from_index(e.size_type_index).generated_name << ";" << LF;

		// Internal enum class
		output << TAB << "enum class Value : value_type {" << LF;
		for (const auto& v : e.values) {
			output << TAB << TAB << v.name << " = " << v.value << "," << LF;
		}
		output << TAB << "};" << LF << LF;

		// Static values
		for (const auto& v : e.values) {
			output << TAB << "constexpr static Value " << v.name << " = " << "Value::" << v.name << ";" << LF;
		}
		output << LF;

		// Default Constructor
		output << TAB << "constexpr " << e.name << "() : value(Value::" << default_entry.name << ") { }" << LF;

		// Value Constructor
		output << TAB << "constexpr " << e.name << "(Value v) : value(v) { }" << LF;

		// Operators
		output << TAB << "constexpr operator Value() const { return value; }" << LF;
		output << TAB << "constexpr bool operator==(" << e.name << " other) const { return value == other.value; }" << LF;
		output << TAB << "constexpr bool operator!=(" << e.name << " other) const { return value != other.value; }" << LF;
		output << TAB << "constexpr explicit operator bool() = delete;" << LF;

		output << LF;

		// Introspection functions
		output << TAB << "constexpr static value_type min() { return " << min_entry.value << "; }" << LF;
		output << TAB << "constexpr static value_type max() { return " << max_entry.value << "; }" << LF;
		output << TAB << "constexpr static size_t count() { return " << unique_entry_count << "; }" << LF;
		output << TAB << "constexpr static size_t nonunique_count() { return " << entry_count << "; }" << LF;
		output << TAB << "constexpr static bool is_contiguous() { return " << (is_contiguous ? "true" : "false") << "; }" << LF;
		output << TAB << "constexpr value_type to_underlying() { return static_cast<value_type>(value); }" << LF;
		output << TAB << "constexpr static value_type to_underlying(Value v) { return static_cast<value_type>(v); }" << LF;
		output << TAB << "constexpr static Value from_underlying_unsafe(value_type v) { return static_cast<Value>(v); }" << LF;
		output << TAB << "constexpr static value_type bits_required() { return " << bits_required << "; }" << LF;

		output << LF;

		// Value functions
		output << TAB << "constexpr auto begin() noexcept { return Values.begin(); }" << LF;
		output << TAB << "constexpr auto end() noexcept { return Values.end(); }" << LF;
		if (is_contiguous) {
			output << TAB << "constexpr static bool contains(Value v) { return (min() <= to_underlying(v)) && (to_underlying(v) <= max());  }" << LF;
			output << TAB << "constexpr static bool contains(value_type v) { return (min() <= v) && (v <= max()); }" << LF;
		}
		else
		{
			output << TAB << "constexpr static bool contains(Value v) { return std::find(Values.begin(), Values.end(), v) != Values.end(); }" << LF;
			output << TAB << "constexpr static bool contains(value_type v) { return std::find(Values.begin(), Values.end(), static_cast<Value>(v)) != Values.end(); }" << LF;
		}

		// Array of values
		output << TAB << "constexpr static std::array<Value, " << unique_entry_count << "> Values = {" << LF;
		for (const auto& v : e.values) {
			output << TAB << TAB << "Value::" << v.name << "," << LF;
		}
		output << TAB << "};" << LF; // End array

		// Private storage
		output << "private:" << LF;
		output << TAB << "Value value;" << LF;

		// END CLASS
		output << "};" << LF << LF;

		// Extra functions

	}

	// END CONFIG NAMESPACE
	output << LF;
	for (auto& ns = cpp.output_namespace.rbegin(); ns != cpp.output_namespace.rend(); ++ns) {
		output << "} // namespace " << *ns << LF;
	}

	// END INCLUDE GUARD
	if (cpp.include_guard_style == IncludeGuardStyle::CStyle) {
		output << "#endif // " << def_macro << LF;
	}

	return output.str();
}

std::vector<cpp_enum_generated> cpp_generator::generate_enums(const cpp_enum_config_final& cfg)
{
	throw std::logic_error("Unimplemented");
}
